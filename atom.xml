<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chtholist.gitee.io</id>
    <title>Chtholist</title>
    <updated>2020-03-27T03:05:11.953Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chtholist.gitee.io"/>
    <link rel="self" href="https://chtholist.gitee.io/atom.xml"/>
    <subtitle>&lt;b&gt; 终焉虽至曲未尽 &lt;/b&gt; &lt;br/&gt;
&lt;b&gt; 末红褪去春意来 &lt;/b&gt;</subtitle>
    <logo>https://chtholist.gitee.io/images/avatar.png</logo>
    <icon>https://chtholist.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Chtholist</rights>
    <entry>
        <title type="html"><![CDATA[Who am I]]></title>
        <id>https://chtholist.gitee.io/post/about/</id>
        <link href="https://chtholist.gitee.io/post/about/">
        </link>
        <updated>2029-02-21T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://chtholist.gitee.io/post-images/1584847823831.jpg" alt="" loading="lazy"></figure>
<blockquote>
<ul>
<li>某二本技校ee方向蒟蒻</li>
<li>技术渣，博客极其简陋</li>
</ul>
</blockquote>
<h2 id="珂学家">珂学家</h2>
<ul>
<li>化石级珂学家，珂群和贴吧很久没去氵了</li>
<li>P图带师，专注于墨鱼图片二创和重制，署名TIAT'S DREAMS，很少打水印。（<del>版权意识淡薄</del>）</li>
<li>作品：<a href="https://piclib.chtholly.moe:2333/posts/query=TIAT'S-DREAMS">TIAT'S DREAMS</a></li>
</ul>
<h3 id="珂学网站">珂学网站</h3>
<ul>
<li><a href="https://www.chtholly.ac.cn/">中珂院一所</a></li>
<li><a href="https://chtholly.moe/">中珂院二所</a></li>
<li><a href="https://wiki.chtholly.moe/%E9%A6%96%E9%A1%B5">中珂院维基站</a></li>
<li><a href="https://piclib.chtholly.moe:2333/">中珂院图库</a></li>
</ul>
<h2 id="wallpaper-engine网页传送门">Wallpaper Engine网页传送门</h2>
<ul>
<li><a href="https://chtholist.gitee.io">原地tp</a></li>
<li><a href="https://chtholist.gitee.io/wallpaper">墨鱼壁纸</a></li>
<li><a href="https://chtholist.gitee.io/wallpaper2">一言壁纸</a></li>
<li><a href="https://chtholist.gitee.io/catball">CAT &amp; COW &amp; LION &amp; CARROT</a></li>
<li><a href="http://chtholist.gitee.io/solar-system/">太阳系模型</a></li>
<li><a href="http://chtholist.gitee.io/the-periodic-table/">元素周期表</a></li>
<li><a href="http://chtholist.gitee.io/tower-blocks/">叠方块</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[珂研随记]]></title>
        <id>https://chtholist.gitee.io/post/worldend_articles/</id>
        <link href="https://chtholist.gitee.io/post/worldend_articles/">
        </link>
        <updated>2020-03-27T02:22:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>现在看来貌似极度羞耻，老中二咯，但总比现在的情况好</p>
</blockquote>
<ul>
<li>Copyright © 2017 - 2020 TIAT'S DREAMS. All Rights Reserved.</li>
</ul>
<h2 id="关于悲剧的探讨">关于悲剧的探讨</h2>
<h3 id="1">1</h3>
<p>从作品的角度说嘛，悲剧和遗憾之美胜过平淡的幸福的光辉<br>
的确于情于理上悲剧这“结果”都是不能让人接受的，拼命地想否定它，我看过有说末日三问不好看的原因是“呐，现实中那么多不如意了，我来二次元不是为了寻找快乐吗”<br>
只可惜苏格拉底老早就说过了“悲剧的效果是使人快乐”，这话虽是说给古希腊悲剧的，末日三问虽然有些差别不过也适用<br>
静下心来想一想，如果不是悲剧收尾，多少人会记住珂朵莉？<br>
落樱飞舞之时，多少人驻足叹惋那即逝的蹁跹美丽？<br>
有时候悲剧之美就这么矛盾</p>
<h3 id="2">2</h3>
<p>动画一开头便给出珂朵莉坠落的画面<br>
让观众知晓了终末时无可避免的不幸<br>
然而此后都以威廉视角来推进剧情线<br>
这样一来就兼顾了珂威二个人的视角<br>
更有人物和剧情的代入感<br>
也让观众的心态变得复杂<br>
矛盾？紧张？不愿放弃的希望？</p>
<p>这个行将终末的世界是无法被拯救的<br>
它的开头和结尾已经写好了<br>
彻头彻尾的悲剧</p>
<p>他的命运已经写好了<br>
她的命运也已写好了<br>
在这十二集的动画里<br>
血红色的开头和结尾<br>
都是彻头彻尾的悲剧</p>
<p>但是他偏要拯救她<br>
她也反过来拯救他<br>
红色的头尾间加入了一抹蓝<br>
那蓝色是苍空，是风平浪静之海</p>
<h3 id="3">3</h3>
<p>在死亡与悲剧的阴影之下<br>
更应该看到人性与希望的光辉<br>
命运的车轮无法转向<br>
黄金妖精的悲剧无法避免<br>
为什么一开头就是dearest drop ？就要让观众预感到结局？<br>
很简单<br>
枯野瑛一开头就让观众知道终焉不可避免<br>
仍要看着珂朵莉从蓝发走向红发<br>
让观众怀揣着颗提着的心<br>
更能感受到在日常的点滴和幸福<br>
这也是珂朵莉的视角<br>
枯野老贼想表达的并不是悲剧的虐<br>
而是幸福<br>
明知不幸终将到来<br>
仍要用尽所有去追寻并守护幸福<br>
“幸福”才是本番主旨</p>
<p>你知道珂朵莉为什么是<br>
世界上最幸福的女孩吗？<br>
你为什么她明知道生命只剩下几天<br>
还要上高台欣赏落日余晖？<br>
你知道为什么她人格在崩坏<br>
却仍笑着迎来每一天？<br>
你知道为什么她消失之前<br>
说自己是最幸福的女孩？</p>
<p>末日时在做什么？<br>
可以来 拯救 吗？<br>
悲剧的魅力正在于此<br>
目睹花朵的凋谢<br>
更能记住花朵的美丽<br>
时间将蓝变为红<br>
将记忆带走<br>
很久以后我们可能已不记得珂朵莉<br>
但心底仍会留有一份她带来的感动</p>
<h3 id="4">4</h3>
<p>看过小说的自然觉得这是我珂出生的场景<br>
那是因为我们见过这个世界在那层轻纱后的残酷真相<br>
但是动画党并不是，对于他们来说，这可以是转世的珂朵莉，也一定是转世的珂朵莉，因为这代表着希望<br>
这也是枯野瑛想要在最后一幕表达的<br>
在珂朵莉的故事终末后<br>
在珂朵莉死亡后<br>
他把目光投向天上之森<br>
投向刚出生的小妖精<br>
在整整一集满屏的血红后<br>
重新回到青色蓝色<br>
这就是所谓的希望<br>
在经历了宿命的残酷后<br>
枯野瑛重新给我们展示了希望<br>
是的，这是一个行将终末的世界<br>
但是，欢迎你，小生命<br>
因为有希望<br>
动画和小说差不少（主旨表达）<br>
看了小说会有新的截然不同的理解<br>
但是再也回不去看纯动画的感觉了<br>
就跟少年派讲那两个版本的漂流一样<br>
你是愿意看到朦胧不真切的曙光和未来<br>
还是愿意看到夕日投放的最后一丝红霞</p>
<h2 id="人物分析">人物分析</h2>
<h3 id="威廉">威廉</h3>
<p>    其实看了第一部后，我就觉得威廉才是最悲剧的人物<br>
    瑟尼欧里斯没有选中他，摩尔宁也没选中他，威廉只适配量产剑帕西瓦尔，如果说圣剑的旨意可以代表上天的意义的话，那么威廉，他本应也理应是一个平平凡凡的人，平平凡凡的准勇者，和悲剧绝缘的。<br>
但是很可惜啊，威廉是个闲不住的人，老是惦记着别人的人，他总在东奔西走，从帝国的这头跑到那头，从一个人的命运跑到另一个的命运那里去，试图帮助别人，试图改变别人的命运，不惜搭上自己的命运。<br>
    在那一天的晚上，接下格里克那个妖精仓库管理员的职位后，威廉是否有认真想过他的人生意义呢？<br>
    为了爱尔和孤儿院孩子们的笑颜，威廉一日又一日地挥剑。为了莉莉娅可以轻松一些，能过得更像一个普通女孩子一些，威廉一次又一次地面对比他强大的异族。而为了偿还往日的余罪，威廉一遍又一遍地指导珂朵莉练习圣剑。在旁人看来，威廉像一个工具人，可是对于威廉自己来说，他自己的人生意义可能就是在于实现他人的人生意义。<br>
    是的，威廉纵使拼尽了全力，可是他仍然没有守护住任何他想要守护的事物，爱尔、莉莉娅、珂朵莉……对于正常人来说，这其中的任何一次失去都足以让其失去希望，靠着以绝望充饥来度过余生。诚然，初到浮游岛的威廉也有这样的表现，但是他接下了妖精仓库的职位，他主动给孩子们做甜食，他面对暴躁紫毛时保持着温和与谦逊，骨子里的他，并没有改变，他的内心仍然热爱着生活，热爱着这个世界，这也是最后珂朵莉能解开他心结的前提<br>
    在夕阳下，在无边的荒野里，在威廉和他体内的兽相处的时光里，在他与他自己的对话里，威廉可否有明白了什么呢<br>
    真正的英雄主义，是认清生活的真相后依然热爱生活。而正因为威廉是彻底的英雄，正因为他面对苦难表现出的坚毅和斗争，他也是彻底的真正悲剧<br>
    某种意义看，威廉和黄金妖精很像，都是自我很薄弱：妖精是对自我的生命没有意识。威廉是对自我的幸福没有意识。<br>
    或者说，都对于自我的价值没有意识？<br>
    旁观者看来，他们都是为他人而活，只是体现不一样，本质却一样：如果太过于重视他人，是不是可以说算是自我的缺失：心里没有“我”，但是心里需要有东西，于是就把别人放在心里，让他人受到关注，受到关爱，从而不会像自己一样，失去自我。</p>
<h2 id="others">Others</h2>
<h3 id="珂朵莉记">珂朵莉记</h3>
<p>   浮游大陆中，威廉摸鱼为业。夜行路，忘路之远近。忽逢妖精仓库，萝莉数十人，中无女装，幼女可怜，妮戈兰体贴，威廉甚异之，宿其中，欲享余生。<br>
   东方既白，便遇一女，蓝发窈窕，自称诺塔，心欢喜，便舍床，随其往，见众女。初害羞，不见影。复做数十甜品，突然后宫。奈芙莲萌，艾瑟雅皮，无秘密兵器之相。众女嬉游，悉如外人。其中落崖被创者，起身自如，惊如天人。寻得密室，见圣剑于壁。<br>
见瑟尼欧里斯，乃大惊，问所从来，具答之。便知妖精，前世幼女灵魂。兜兜转转飘逸，化为人型。自云先世犹存羁绊，伴魔力侵蚀而替人格，不复存焉，遂与外人间隔。问今为何况，乃不知有爱，无论幸福。威廉闻诺塔之属且赴戎机，一一为具教所学，皆有得。众女各复延其三人，皆盼归。别数日，心慌。威廉愀然云：“呜呼！孰谓汝遽去吾而殁乎！”<br>
既久，天雨雨，却闻战报，且败。及跪下，心破碎，欲觅死。举头即望诺塔，莺赞崩疾，遂拥，泣涕涟涟。<br>
   巴洛尼，护翼军也，闻之，遽然前往。语大贤者，威廉惊，后弃诺塔而随其往。</p>
<h3 id="寇马镇独吟">寇马镇独吟</h3>
<p>“说话一定是给人听见的吧<br>
就算是喃喃自语，听者也有自己<br>
那如果我说的话传达不到任何人的耳中<br>
只是被风吹走<br>
那还有意义吗”<br>
『─爸──爸─』<br>
无法传达给任何人。打动不了任何人。<br>
只能溶于灰色的荒野，然后消失。</p>
<p>轰然倒塌下的景色<br>
已经不知注视了多少次了呢<br>
面目全非的身影<br>
已经目睹了不知多少个了呢<br>
从灰色梦中钻出的痛苦<br>
请停下来吧</p>
<p>“爸爸，爸爸<br>
我就在这里<br>
在你的记忆停顿的地方<br>
在这段物语开始的地方<br>
在这段羁绊终了的地方<br>
你知道什么能比时间更长久，<br>
比空间更广远吗<br>
是爱<br>
只有它<br>
能抵达世界的终焉<br>
我沉眠于记忆之海<br>
我徘徊于永恒之时<br>
沧海桑田<br>
在你的记忆里我永远存在<br>
而在我的记忆里，永远缺少一个你</p>
<p>守在故事开始的地方<br>
就能重新书写故事吧<br>
当残阳之红坠落之时<br>
当七彩之虹绽放之时<br>
我们必定会再会的<br>
在约定的那个地方<br>
在相遇的那个地方<br>
”</p>
<h3 id="对比ngnl0">对比ngnl0</h3>
<p>游戏人生剧场版末日三问<br>
两个番真的有超多相似之处<br>
都是在末日的背景下的拯救<br>
但不同的是一对用生命换来了新世界<br>
一对却只是给这个行将终结的世界增添了抹红色<br>
利库他们结成了夫妻并肩作战<br>
但威廉直到无法挽回时才明白了自己的感情..利库他们在一起时战无不胜唯一一次分开却天人两隔<br>
休比是人类最强战力，但是面对小吉却只有271秒<br>
威廉他们是分开都能再相遇唯一-次一 起战斗却成为告别<br>
珂朵莉是浮游大陆最强战力，但是纵使用上了星神之力也只能保住一架飞空艇<br>
利库作为草芥，用尽一切智慧，以最弱战胜了最强<br>
威廉终其努力也只是准勇者，却能用尽一切办法，杀龙弑神，但最后面对兽呢</p>
<h2 id="他人分析">他人分析</h2>
<p>（出处均不详）</p>
<h3 id="1-2">1</h3>
<p>   该作画面表现了足够的诚意，适当却不影响整体的福利画面，少女可爱的细节体现。复古朋克的飞艇，西式复古的建筑，这个世界平和的时候，就像那美好的斯卡保罗集市一样，浮游岛像是梦里的城市，《SAO》巨大的城堡艾恩格朗特，梦幻的天空之城。<br>
   没有很多的激烈精彩的大制作打斗场景，让人最深刻的却是女主角珂朵莉最后一战，红色的夕阳下，少女一头蓝发尽褪去变成红色，像是蝴蝶起舞一样，挥动巨大的圣剑，被兽刺穿后，展开彩色的翅膀自爆杀去了许多的“兽”。<br>
   音乐方面，音乐制作Lantis也是具有实力的音乐娱乐公司。音乐由加藤达也负责，看过《境界线上的地平线》想必无法忘记那首《通し道歌》，那便是加藤达也曾经担当负责的的音乐，这一部作品印象曲加藤达也亲自编曲后的苏格兰民谣《斯卡保罗集市》也是广受好评，在第一集展示了这个末世浮游岛居民依旧努力幸福生活的风情，为珂朵莉威廉的爱情开始奏乐；而再最后一集，这是相爱的两人生离死别，却依旧思念地哀伤。<br>
   插曲“Always in my heart”，每每响起，必然也是调动情绪最棒的地方表现极其出色切合氛围。<br>
   故事整体结构清晰，人物、音乐、剧情都很丰满，不错的人物设定，出色的音乐搭配，剧情稳定，远胜这几年许多轻改作品。不执着于萌或者燃，能营造出伤感但也不矫情保持着克制。《末日拯》讲好了一个故事，讲好了一个吸引人的故事。尽管篇幅限制，经费限制等种种问题在后期出现很多坑未填，声优也并非知名。我还是认为这部作品的优点盖过了这些缺点，这是一部值得一看的良作。<br>
   《末日拯》带来的是一种感觉，想传达出某种意境，让台下读者能闻到香气：宁静、清爽。在末日的世界，无意真的寻找那么一个来拯救异世界的嘴炮勇者，注目于末日中每一个战士”黄金妖精“。在末日的世界，无可违抗的命运面前，积极而无畏地去抓住飘渺地希望，在珍贵的日常感受幸福。<br>
   你觉得幸福究竟是什么呢，如果能和喜欢的人的一起执子之手白头到老，永远当一个幸福的傻瓜就好了，那想必是无比的幸福的事情吧。然而很多时候现实并不允许如此，你要面对的不仅仅是各种方面的压力，还有两人心意相通走到最后一步。</p>
<h3 id="2-2">2</h3>
<p>   抱歉……我已经，绝对不可能再获得幸福了……因为，我早已被幸福包围。”说罢，珂朵莉纵身跃下飞艇，笔直朝地面落去，她的身体穿过浓厚的云层，跟她一起掉落的还有大片的飞艇残骸。<br>
   坠落的速度很快，但珂朵莉眼前仍旧是重重叠叠的积云，她突然在身后幻化出巨大的星空蝶翼，远远望去，就像是天空突然出现了一颗蓝色的流星，闪烁着的彗尾将天空一分为二，她猛然加速冲破云层，在身后留下三个逐渐消散的云环。<br>
   飞艇的残骸掉落在沙漠间，扬起灰白的尘土，在临近地面的地方，一蓝一紫两道光交错在一起，珂朵莉用自己的翅膀护住了坠落的威廉，这个她第一次喜欢上的男人。<br>
   珂朵莉想起28号岛上的那次邂逅，想起威廉亲手为她做的黄油蛋糕，想起那夜在仓库中的求婚告白，想起他们共同生活过的一点一滴，她还想起自己的约定，他的战斗全部由自己来继承的约定。<br>
   珂朵莉笃定地提起绯红的迪斯佩拉提奥圣剑，转身盯着如潮水般涌来的第六兽，血红色的瞳孔里毫无畏惧，她在用行动向世人诠释，什么叫做“虽千万人，吾往矣”。<br>
   手持利刃的少女孤身攻入兽群，灵巧地在敌人之间穿梭，于沙漠中翩翩起舞，兽的残肢和血液如天女散花般溅射开来，血液喷洒在她的红发上，溅射到她的脸颊上，她已经分不清这是敌人的血液，还是自己的血液了。<br>
   夕阳映红了整片天空，鲜血洒满了整块沙漠，珂朵莉仍旧在兽群的包围中奋力厮杀着，双拳难敌四手，她终于因为体力不支而被兽群的触手穿透了胸膛，斑斓的蝶翼再次出现在她身后，蝶翼以飞快的速度生长着，一会儿就遮住了整片天空，随后急速坍缩成一点，光球猛地炸裂开来，彩光直冲霄汉，轰的一声就将兽群全部从沙漠中抹去了。<br>
   妖精兵被赋予了使用魔力与兽战斗的使命，但魔力的长期使用会让人记忆丧失，人格崩坏。就在刚才，珂朵莉燃尽最后一丝魔力，剧烈的爆炸在消灭兽群的同时，也将她最珍贵的记忆剥夺了。<br>
   珂朵莉的脑中一片空白，她不解地看着脚下，看着这个陌生的男人，她理应忘了关于他的一切，但不知道为什么，一股熟悉的感觉涌上心头，她忍不住流泪了，她大概真的已经忘了，这个曾让她说出自己是世界上最幸福的女孩的男人。</p>
<h3 id="3-2">3</h3>
<p>   忧伤有种隐秘的力量，就像为什么人们知道是悲剧，还要去看，而且留在心里时间更久。忧伤是很美的，它兼顾了幸福和酸楚。</p>
<p>花开——<br>
花谢——<br>
桃色的花瓣飘散零落，一片，又一片<br>
啊，我深爱的人儿。<br>
您留下的泪水，就让愚臣来捡起它吧。<br>
聚集众日，便会化身高傲的花朵。</p>
<p>   这是八月社的作品《千之刃涛、桃花染之皇姬》中的诗句。珂朵莉如同这飘零散落的桃花，即使凋落，终有一日，也会再一次地化身成高洁的花朵，深深地扎根在这无可救药的大地上的吧？<br>
   因为是出生意味着死亡的兵器，所以柯朵莉追求幸福，也不是常见的成长，而是走出脆弱来追求幸福。这让故事不因虐而感人，而是温暖的、触动你的内心。情节虽然常见，却也包含新颖，流露出感情，因此情节方面虽不登顶封神，却也让人津津有味。<br>
   亚里士多德指出悲剧的目的是要引起观众对剧中人物的怜悯和对无常命运的恐惧。宿命论作为典型的消极命观，很容易就能将剧作引向悲剧，因此宿命与悲剧常常是捆绑关系。<br>
   然而，比起宿命论（特别是强宿命论），宿命本身其实并不那么令人消沉，冬去春来、四季更迭、生死轮回，皆是宿命，不遂人愿是悲剧、无力扭转是悲剧，但却可以赋予积极的意义，有点唯心地说，人生轨迹的主线、终点我们改变不了，但我们的态度、主观能动性可以发挥充分的作用去改变我们的体验甚至一些支线。<br>
   在这个行将终结、完全看不到救赎的世界，如黑暗中飘摇的火苗般的主角们如何在注定悲剧的命运中“无谓”地挣扎、克服脆弱、找到归宿、收获幸福<br>
   两首英文歌，仿佛是珂朵莉对威廉的真情告白，在珂朵莉迷茫而无助的时候，是爱情给了她活下去面对现实的勇气，是威廉让她从消逝自我的恐惧中挣脱。当她鼓起勇气再次拿起圣剑，接受自己命运之时，她不再是那个被世界存亡而左右的妖精兵，她有一个无论如何都要保护的人，她有着无论如何都要实现的约定。<br>
所有人都仿佛无根之萍，没有一个绝对安全的领域。<br>
所有人都在寻求救赎<br>
   从第一话《斯卡布罗集市》那凄美忧伤的旋律开始，就已经暗示了这是注定无法挽回的悲剧，本作同样是以既定的悲剧终点为目标，通过情感的刻画与人物心理塑造进行层层铺垫、推进，最后彻底毁灭来展示人物必然的坎坷命运，但是最后收尾的却是那一瞬间美好而短暂的幸福，将悲剧感再提升了一个层次。<br>
   幸福，可以说这是一个贯穿整部作品的主题。妖精仓库里日常的幸福，威廉想要守护的与想要给予的幸福，珂朵莉得到的幸福，在这个末日世界中都有着非常沉重的意义。有人说，珂朵莉所说的自己是“世界上最幸福的女孩”只是自欺欺人，但是如果联系珂朵莉的一生，你会发现她说出这句话的时候是具有满足感的。<br>
   “黄金妖精”的设定，注定了珂朵莉要背负极为残酷的命运。她们仅仅是星神的碎片，为了拯救和自己无关的兽人们而战斗的兵器，随时都要赴死，即使没有牺牲也要由于力量的消耗被前世记忆腐蚀，彻底换成另一个人。也就是说，要么肉体死亡，要么精神上死亡，无论哪一种都相当残酷。<br>
   因此，珂朵莉的一生是相当短暂的，背负着战斗的命运，接受必将毁灭的结局。但是威廉的出现让她悲剧的一生体验了一份美好的回忆，不仅让她有了可以依靠的肩膀，还有了这个花季应该有的最重要的东西——爱。</p>
<p>抱歉我已经 绝对不可能再获得幸福了<br>
因为我发现<br>
其实我<br>
早就已经被幸福包围了</p>
<p>所以，珂朵莉的幸福，概括起来就是三个字——“小确幸”，小小的，确实的幸福。有人说如果要让一个已经尝过无数黄连的人体会什么是甜，很简单，一口糖就足够了。对于珂朵莉来说，在本来坎坷的命运基础上她已经体验到了本来不可能体验的东西，拥有了那份美好的回忆，所以那就足够了。我们没有办法把自己的幸福观强加到别人身上，珂朵莉的幸福，只有她自己能认定。</p>
<p>因此——<br>
不管别人怎么说<br>
我都是世界上最幸福的女孩<br>
——珂朵莉</p>
<p>   而对于观众来说，更多的人明显希望她能获得更多的幸福。因此我自己浅薄的理解认为：<br>
   正是因为屏幕中的少女对幸福的满足，面对毁灭含泪露出的笑容，与观者基于不希望她就此毁灭，不现实地期盼更美好的未来能发生这一愿望产生的强烈矛盾，才让最后结局的泪点能达到泪腺崩坏的地步，也让这种悲剧的演绎可以推向更高潮。<br>
   并不是所有的TE都能打动人心，有的TE如果仅仅是为虐而虐，反而会让人反感作者这种扭曲的三观。只有逻辑自洽、情感铺垫充足的悲剧，才能让人印象深刻。就这一点来说《末日时》确实做到了，而且在此基础上还包含了更多值得探讨的话题。虽然动画的定位是做成了珂朵莉的故事，但如果结合作品的世界观和设定来看的话，这部作品本身是一个多重悲剧：<br>
珂朵莉等黄金妖精的悲剧，必将毁灭的命运。<br>
威廉的悲剧。再一次无能为力，没办法拯救喜欢的人。<br>
人类的悲剧。被自己的行为毁灭，并成为延续悲剧的工具（人类变成了兽，破坏着星神塑造的世界）<br>
星神的悲剧。被自己想要守护的孩子们因为他们的无知所杀（人类以为用星神的碎片就能对抗兽）<br>
   如果仔细看《末日时》的设定的话，你会发现枯野瑛搭建了一个非常残酷的舞台，为塑造人物和表达主题提供了一个广阔的空间，甚至有珂学家分析里面包含着一定程度的诺斯替主义思想。但是动画的处理更加巧妙，没有对这一部分进行着重的刻画，而是对妖精仓库日常以及珂朵莉的幸福着墨，在这庞大的末世背景的对比下反而起到了非常好的效果。<br>
   少女们在毫无希望的世界中做着无所谓的努力，即使未来终将是悲剧，但也要在此刻欢笑，努力把握当下的幸福，然后笑着面对早已注定的死亡，我想，这就是《末日时》表现的一个很重要的主题。</p>
<p>再说说威廉的悲剧<br>
   曾经我的语文老师说过，世界上最让人后悔而绝望的事情，就是看着自己想要守护的东西濒临毁灭而自己却无能为力。<br>
   这种痛苦，就是威廉一生中不断重复的。<br>
   无论是500年前，还是500年后，不管是艾尔梅莉亚、莉莉娅还是珂朵莉，明明拥有着强大的实力，但是却谁也拯救不了——“这种强大，根本抓不住任何人的手。”<br>
   TV第一话他与格里克的对话，就可以看出在想守护的东西都失去后，他就已经没有生存下去的意义了，直到他来到了妖精仓库，遇到了珂朵莉。珂朵莉的存在本身非常特殊，在她身上又看到了自己曾经失去的一切的影子，所以想要通过她来弥补自己，TV11话他的自白也证明了这一点。<br>
   珂朵莉给了他重新生活下去的意义，也让他心中萌发了爱意，如同上天给予他的礼物一般，他对珂朵莉有着一种非常平稳成熟的温柔，他以为自己只要给予她幸福就能救赎自己。<br>
   但是，这或许还不能称作自我的救赎。他永远也没办法放开过去，在最后也没办法理解他的存在其实对珂朵莉来说已经是幸福。这种困境直到小说第五卷，他才完全解脱（这里就不细说了，虐……）<br>
   因此，威廉和珂朵莉，两个人的命运不断交织在一起，相互给予相互拯救，层层推进到最后TV12话，枯野瑛加上的这段对白就顺理成章，并把两个人的羁绊进行了完美的概括</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[末日三问网易云评论拾取]]></title>
        <id>https://chtholist.gitee.io/post/worldend_comment/</id>
        <link href="https://chtholist.gitee.io/post/worldend_comment/">
        </link>
        <updated>2020-03-27T02:16:35.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>来源：TVアニメ『終末なにしてますか?忙しいですか?救ってもらっていいですか?』オリジナルサウンドトラック「青い記憶」</li>
<li>Copyright © 2017 - 2020 TIAT'S DREAMS. All Rights Reserved.</li>
</ul>
<hr>
<h2 id="前言">前言</h2>
<p>大概在<code>DEAREST DROP</code> 6000评论的时候，就常驻在评论区了，就跟p叔常住贴吧一样，ost每首歌都逛过，大部分评论都看过。<br>
娜娜之前转发过一个视频，说的是互联网时代是个健忘的时代，看似数据都能云端存储，方便快捷而安全，然而信息数据化的代价却是谁也无法承受的，贴吧的案例就摆在这呢，海量的信息伴随着互联网的记忆在一夜之间就无影无踪，道是烧毁一座图书馆也无过<br>
谁又会想到墨鱼在网易云音乐的命运也是如出一辙呢？<br>
科普，安利，反黑，应援，冲热评，冲万评………不少珂研和思考也都写在网易云，当时居然不记得保存……<br>
后来的事都知道了，某一天突然什么都没有了，真的很难受，失去的不仅是满满的记忆，还有一份不可重来的热忱</p>
<h2 id="我个人的网易云评论拾取">我个人的网易云评论拾取</h2>
<blockquote>
<p>现在再回看有那么点羞耻，但更多感受到的是真切的情绪。</p>
</blockquote>
<ol>
<li>
<p>两年了<br>
初心不变<br>
为了更多人能知道这部作品<br>
为了墨鱼不再是墨鱼<br>
为了我珂的幸福能被更多人铭记</p>
</li>
<li>
<p>离动画放送结束已然过去了两年多了<br>
不知大家是否还记得当年的那位妖精<br>
还有属于她的幸福故事呢？<br>
是否还记得陪伴自己度过的触动呢</p>
</li>
<li>
<p>‌每个人理解不同，<br>
有的人最后自闭，有的人悟出幸福收获感动，<br>
只有你自己看了才知道</p>
</li>
<li>
<p>珂朵莉？你还在吗？<br>
多么希望这只是一场梦啊<br>
哪怕这是艾路可的梦<br>
多么希望这只是一个玩笑啊<br>
哪怕这是枯野老贼的愚人<br>
又是一年四月时<br>
两周年了，珂朵莉<br>
蓝发依旧呢</p>
</li>
<li>
<p>春节前<br>
我们接珂朵莉回家<br>
那时候我说已经很满足了<br>
春节后<br>
珂朵莉殿军<br>
岂止是满足？<br>
如今 走出妖精仓库的换作是我们了<br>
喜欢着珂朵莉的珂学家们<br>
新的一年<br>
一定能守住自己的幸福</p>
</li>
<li>
<p>你看到妖精仓库门上的春联<br>
你看到菈琪旭在厨房里煮汤<br>
你看到奈芙莲那灰色的眼眸<br>
你看到艾瑟雅正追着小妖精<br>
你看到墙上挂着珂威的婚照。<br>
你知道这都意味着什么<br>
你在心里说到<br>
&quot;春节快乐，我最爱的妖精仓库&quot;</p>
</li>
<li>
<p>‌2019.1.31<br>
珂朵莉在世萌8进4遗憾输给雪乃<br>
珂朵莉，不管结果如何，<br>
你仍然是在末日尽头最幸福的女孩，<br>
你有非常爱你的珂学家，<br>
他们会接你和威廉回家，<br>
等你和威廉吃黄油蛋糕。<br>
你从来没有被抛弃过，<br>
珂学家为你奋斗为你坚持为你努力<br>
那么，欢迎回家，珂朵莉</p>
</li>
<li>
<p>跨年时在做什么？<br>
有没有空？<br>
仍和你最重要的人在一起吗？<br>
你看着一位女孩从蓝发到红发<br>
你也能看着他（她）从黑发到白发吗？<br>
2019<br>
请<br>
守住自己的幸福</p>
</li>
<li>
<p>那是漂浮在蔚蓝天空上的一座岛屿，<br>
岛屿上有座古老的城市，<br>
在那里的集市上，<br>
杂货摊主正铺开着香料，<br>
欧芹、鼠尾草、百里香、迷迭香，<br>
你是否有看到过一个女孩从那里经过，<br>
她留着苍空色的头发，<br>
戴着灰色的大帽子，<br>
请代我向她问好，<br>
告诉她黄油蛋糕已经做好了，<br>
欢迎回家。</p>
</li>
<li>
<p>那是漂浮在蔚蓝天空上的一座岛屿，<br>
岛屿上有座古老的城市，<br>
在那里的集市上，<br>
杂货摊主正铺开着香料，<br>
欧芹、鼠尾草、百里香、迷迭香，<br>
你是否有看到过一个女孩从那里经过，<br>
她留着苍空色的头发，<br>
戴着灰色的大帽子，<br>
请代我向她问好，<br>
告诉她枯野老贼已经被刀了，<br>
欢迎回家。</p>
</li>
<li>
<p>“枯野瑛先生回来了”<br>
末日时在做什么？可以再见一面吗？<br>
第七卷刚刚发售了<br>
这卷里缇亚忒奇迹般的活了下来呢<br>
承担起了拯救黄金妖精的命运<br>
另外，珂朵莉也……………………<br>
在她身边还有一个小孩子……<br>
希望大家可以多多去支持第二部<br>
ありがとうございます</p>
</li>
<li>
<p>‌之前因为对这番的喜欢<br>
我也有过这样的误解<br>
其实这首歌和这部番的关系就像官方说的<br>
歌提高了番的意境和档次<br>
番则给了歌更多的情感和故事</p>
</li>
<li>
<p>动漫版本也是改编自斯卡布罗集市民谣的<br>
这首歌奠定了动漫的基调 一开场便是本曲<br>
而当最后一幕再次响起斯卡布罗集市的旋律时<br>
您就能明白为什么本番被称为“最强之泪”了<br>
强烈安利<br>
可以去听听我歌单 本番的其他配乐也都极有感染力</p>
</li>
<li>
<p>‌你是否有感觉到致郁？<br>
是否对结局感觉到不甘心？<br>
是否有想过要拯救这个悲剧？<br>
是否有质疑过珂朵莉自以为的幸福？<br>
是否想过对于珂朵莉 什么才算幸福？<br>
是否想过幸福到底要如何定义？<br>
幸福有通用的标准吗？<br>
自己认为幸福就是幸福吗？</p>
</li>
<li>
<p>对于最后一幕那个蓝发小女孩，我想说，不要强行把小说的真相科普给只看过动画的人，对于动画来说，那可以理解是重生的我珂。小说是道尽末日时的无望，但老贼在动画做的这个修改就是要留下美好的念想，在末日时留下点希望</p>
</li>
<li>
<p>终焉虽至曲未尽<br>
末红褪去春已来<br>
三百六十五天去<br>
今世唯爱珂朵莉。<br>
给“唯爱珂朵莉”大佬写的(●—●)</p>
</li>
<li>
<p>两年已过<br>
人来人往<br>
不变的是对那抹苍空湛蓝的向往<br>
这部番我们终会忘记<br>
但是那个女孩对于幸福的追寻<br>
以及这份意象带来的触动和影响<br>
将伴随着我们一辈子</p>
</li>
<li>
<p>‌微笑的食人鬼，苏醒的人类<br>
飞翔的妖精，咆哮的十七兽<br>
喧嚣的妖精仓库<br>
如今也在持续着简单平凡的生活<br>
晴空染就的蓝发<br>
曾经见到那道身影<br>
刹那间闪过<br>
威廉和珂朵莉<br>
他们往昔许下的承诺<br>
仍在我们的心里淡淡的萦绕<br>
也许时间总会冲淡一切<br>
但我们见到的故事<br>
永远不会完结地持续着</p>
</li>
<li>
<p>你觉得幸福究竟是什么呢，<br>
如果能和喜欢的人的一起执子之手白头到老，<br>
永远当一个幸福的傻瓜就好了，<br>
那想必是无比的幸福的事情吧。</p>
</li>
<li>
<p>珂朵莉？你还在吗？<br>
多么希望这只是一场梦啊<br>
哪怕这是艾路可的梦<br>
多么希望这只是一个玩笑啊<br>
哪怕这是枯野老贼的愚人<br>
又是一年四月时<br>
两周年了，珂朵莉<br>
蓝发依旧呢<br>
‌</p>
</li>
<li>
<p>威廉：我舍弃了羁绊，只为守护露珠般转瞬的幸福。奈何创伤不许，准勇者的余日迷茫而无着。我仍悔恨，我辜负了平静美好的每一时每一刻。该发生的，迟早会发生吧。虽没能避免悲剧的降临，但我会用生命守住你的那抹蓝，让那风平浪静之海倒映着苍空。如果你问我你是谁，那便是世上最幸福的女孩。</p>
<p>珂朵莉：我抛弃了羽翼，只求得到夕阳般美丽的幸福。奈何前世不许，妖精的一生本短暂而薄凉。但我不悔，我珍惜了欢乐甜蜜的每一分每一秒。该留下的 ，永远会留下吧。虽不能避免爱恋的开始，但我会化作你心中不灭的花朵，让我们的春天没有熄灭的时刻。如果天上有森林，那便是我爱过你的地方。</p>
</li>
<li>
<p>斯卡布罗集市为英国中世纪民谣<br>
没有真正意义上的“原唱”<br>
西蒙将其创造性改编<br>
作为《毕业生》主题曲<br>
现代所有改编都以此为基础<br>
最广为人知的是莎拉布莱曼的版本<br>
山田露珠的版本也很出名<br>
那是为一个幸福的蓝发女孩吟唱的</p>
</li>
<li>
<p>我想是因为末日三问<br>
它所带给人的感触和共情是跨次元的<br>
不管时隔多久，不管是什么样的人群<br>
只要对幸福有着追求<br>
只要能理解悲剧之美<br>
那么你一定能收获末日三问带来的感动</p>
</li>
<li>
<p>把斯卡布罗集市选作插曲<br>
将这部作品上升了一个台阶（监督原话）<br>
末日只是传达了歌曲的其中一部分含义<br>
让我们对歌曲有了更深的理解<br>
但不是只有看过的人才听得懂<br>
打个比方<br>
末日是站在斯卡布罗集市的肩膀上<br>
借了它的光<br>
田翻唱的这首民歌赋予了另一种意义。歌词“香芹、鼠尾草、迷迭香和百里香”象征着爱情的品质，又有一种说法是抵抗死神的灵符。威廉与珂朵莉之间的爱情在这个濒临灭绝的世界中绽放出来的美好被这首歌以凄美的旋律演绎着，更让人潸然泪下。</p>
</li>
</ol>
<h2 id="其他网易云评论拾取">其他网易云评论拾取</h2>
<ol>
<li>
<p>悲剧就像美酒，欲罢不能之后是宿醉的苦果，令人又爱又恨。<br>
有缘遇见这部作品真的很幸运<br>
珂朵莉！是世界上最幸福的女孩！</p>
</li>
<li>
<p>没看番之前觉得很好听，很唯美，现在觉得真的是听不下去了，特别是知道小说后续，心在滴血。不只是心疼珂朵莉还有苦苦等待的威廉</p>
</li>
<li>
<p>这首歌给我一个错觉，那就是爱情这个东西不是个伪概念<br>
这个番给我一个错觉，那就是幸福这个东西不是个伪概念</p>
</li>
<li>
<p>“如果真爱有颜色，那么一定是记忆染成的蓝色”这部番很有纪念感，是我和我喜欢了几年的人，第一次一起看的番剧，喜欢的人送我的第一个生日礼物也是《末日》的小说，虽然我还在等待，但是希望所有看过这部番的人，都能收获幸福，都能成为世界上，最幸福的人。</p>
</li>
<li>
<p>人活着就是为了珂朵莉—鲁迅</p>
</li>
<li>
<p>这个版本并不是唱的最好的，但确最打动我的。原版在讲述一个遥远的故事，可这个版本，仿佛那个对你弯着眼眸，唇含笑意的女孩子就正拉着你，时而眼光闪闪发亮盯着一旁贩卖的新奇物件，时而回转身来向你撒娇讨要喜欢的东西。在这充满了幸福与快乐的时光里却蕴含着的一丝道不明的哀伤，如初恋般甜蜜与苦涩</p>
</li>
<li>
<p>突然感慨，人其实是很容易满足的，只要有一段温暖的亲情，一段惹人发笑的友情和一段永恒的爱情</p>
</li>
<li>
<p>第一次听到时，只是觉得好听，仅仅是一般的好听，可是在故事的结局，配上这首音乐，心里感到无比的难受，以后每一次听到，眼泪都在眼眶里打转，只是强忍着，去感受悲伤</p>
</li>
<li>
<p>说老实话，看着评论从231到现在的14451，我知道这个世界上最幸福的女孩永远不会孤独了</p>
</li>
<li>
<p>多想再听你叫他一声太太；<br>
多想再见你害羞时的样子；<br>
多想再陪你散一整天的步；<br>
多想再吃你做的黄油蛋糕。</p>
</li>
<li>
<p>说实话，我看番基本不怎么投入感情，但这个我是莫名其妙后面突然泪崩～感觉哭一下也不错呢！</p>
</li>
<li>
<p>从前没看这部番时就时常刷到这首歌，虽然不明白这首歌词是什么意思，可是每每听都能感觉到它表达出的强烈的爱还有那满满的回忆。<br>
世界上最幸福的女孩ーーーー珂朵莉。</p>
</li>
<li>
<p>现在害怕听到相关歌曲和MV ，这是我唯一一部不敢看第二遍的番，真的害怕自己忍不住哭出来，我宁愿你不做最幸福的女孩，我只希望你每天都能看见自己喜欢的人[心碎][心碎][心碎][心碎][心碎][心碎][心碎][心碎]</p>
</li>
<li>
<p>看番前，听always in my heart：旋律很好听，想知道是谁做的<br>
听到第一集的ScarboroughFair：哦这个我听过，旋律好美<br>
最后一集听到ScarboroughFair：(当场猝死)<br>
现在听所有的末日时配乐：都感觉有点忧伤</p>
</li>
<li>
<p>当时开学前三天看了这番，被朋友骗是he，第一集感觉这歌好听，最后一集再听却扎心到崩溃，以至于开学后我几个朋友都觉得我是不是得了抑郁症，现在听依旧有一种心中隐隐作痛的感觉，珂朵莉在我心中一直是最幸福的女孩</p>
</li>
<li>
<p>当网易云推给我这首歌时，我觉得应该看完番之后再来听会更有感触，用心去体会，她将感染你的内心，打动你心中的那根弦。人的情感不是说来就来的，慢慢的你会在不自觉的爱上她，当分离时更能感受到。</p>
</li>
<li>
<p>第一集听到这首歌觉得超级好听，最后一集听到这首歌，觉得，整个人都不好了啊啊啊啊寄刀片寄刀片！！！幸福你妹啊！给老子好好活下去啊混蛋！！给我原地结婚啊啊啊！(ノ=Д=)ノ┻━┻</p>
</li>
<li>
<p>是我听过最温柔的版本。</p>
</li>
<li>
<p>珂朵莉，为什么你要承受记忆消散的折磨?为什么只有你要独面死亡？<br>
你本与其他活泼可爱无忧无虑的普通女孩一样啊！<br>
你坚信幸福，你遇见幸福。<br>
最后一刻，你为什么还要含泪笑出来啊！不要感谢任何人了！求你再次痛快地哭出来吧！<br>
但请相信，有一位名为“珂朵莉”的黄金妖精，她是世上最幸福的女孩！</p>
</li>
<li>
<p>与珂朵莉相遇时的bgm，奠定了整篇故事的宁静与辉宏，同是也预示这她的死亡，听到这bgm我大概就知道了珂朵莉的结局，不过很美，很美，这可能就是所谓幸福把。</p>
</li>
<li>
<p>动漫刚开始毫无感觉地听完了这首歌，最后一集的时候带着泪重温了这首歌</p>
</li>
<li>
<p>这首歌是以战死沙场的士兵口吻请求侥幸生还的战友替自己给身在集市中的恋人转达自己对她的思慕，紧扣动画反复强调的对战斗结束后的假想。歌名又和男女主第一次相遇的场所对应，动画选这首歌作为印象曲真的是神来之笔，</p>
</li>
<li>
<p>于很多人而言这首歌早不再是歌，而是[渴望得到救赎的青年教官]与[注定赴死前拼命追求幸福的妖精兵]的璀璨日子。威廉与珂朵莉、爱尔梅莉亚、黎拉，本应有的灿烂故事，却因世界注定走向末日而化为悲伤。可正因如此，枯野老师才好令[彼此的约定与想要达成的愿望等那些本来的美好]更加美丽无比。亦表达自己</p>
</li>
<li>
<p>“除了她自己，没有人觉得她幸福。”<br>
“但这就是幸福的真谛不是吗？”<br>
“……”</p>
</li>
<li>
<p>这首歌在第一集的时候配合着珂朵莉的身影，有一种类似风之谷开头那种空灵的感觉，而片尾配合珂朵莉和威廉的身影及独白，却又那么的悲伤[流泪][流泪][流泪]看完难受了好久哇，但我还想把小说补完</p>
</li>
<li>
<p>果然还是接受不了结局，，，连着3天看完了，看完最后一集头天失眠了，第二天晚还是忍不住哭了，，，想从头再放一遍又一遍，然，这不过只是在无意义的循环中让他们假的好好在一起罢，不过只是不愿接受的抗拒罢，不过是在用不可改变的事实折磨自己罢，，，于是唯有在这悲情中完美的歌曲里不断地享受折磨</p>
</li>
<li>
<p>这首歌本来是为了表达战争，女子在等待出征男人的回归，而这首scarborough fair的感觉却完全不同，所有的she改为了he，所有的her改为了his，在那个浮游城的世界中，高个黑发的男子等待着蓝发少女的归来，这是完全不同的意境与意义，如果可以的话，真希望他们能永远在一起生活，一起穿梭在大街小巷。</p>
</li>
<li>
<p>这个曲子最开始听只是因为好听。但是看到最后一集的时候这个曲子的前奏一响起来的时候眼泪就再也忍不住了，瞬间就哭了。这首歌很奇怪地符合了这部番的主题，还以一种奇怪但是近乎完美的方式把内心中的感情瞬间燃烧起来了。</p>
</li>
<li>
<p>末日时在做什么？——聆听呼唤<br>
有没有空？——随时恭候<br>
可以来拯救吗？——On my way!</p>
</li>
<li>
<p>以前听斯卡波罗集市感触没有现在那么大<br>
看多了动漫中泪目的情节总是觉得不会再有感触了<br>
看见那些&quot;不幸福&quot;的人们笑着说&quot;我很幸福噢&quot; 眼睛总是红红的<br>
封面的珂朵莉开心地和威廉一起走在集市上<br>
我想 甚至等到她的头发只有一丝丝蓝的时候 她的时间仅剩一点点的时候<br>
她也会那样做 因为她的身旁 是她的世界</p>
</li>
<li>
<p>一周目第一集听这歌感到惊艳，那样的景色配上这样的bgm，然而最后一集这个bgm一响起来内心崩溃，至于为啥说一周目第一集，二周目第一集再听这bgm还有空感觉到惊艳？都哭出来了好吧</p>
</li>
<li>
<p>最后柯朵莉战斗中仍起舞的身姿，一首斯卡布罗集市平静的叙述着最应该燃烧的故事，配乐可以说直追EVA破的给我一双翅膀了</p>
</li>
<li>
<p>在看第一集的时候听到这首曲子就感受到一股淡淡的忧伤了，没想到结局竟然如此虐心，到现在也没敢看完。</p>
</li>
<li>
<p>一对新婚夫妇去集市买东西  他们约定傍晚回家   妻子却再也等不到被征兵带走的丈夫  于是集市每天都会传来这首歌  这不是唯一的流传版本但是我最喜欢的  一旦自己的心意再也传达不到对方那里  才会更珍惜吧...</p>
</li>
<li>
<p>我在集市上遇到一个奇怪的人。好奇怪啊，明明早已做好战死的准备，和他相遇之后我却开始惧怕死亡，惧怕消失，只是因为我和他约好了，我一定会活着回来，吃一口黄油蛋糕。后来，他又和我约定，他说他一定会娶我，给我幸福。我想，我这次可能没有机会守约了，从遇到你的那一刻，我就已经是最幸福的人了。</p>
</li>
<li>
<p>非OIer忽略 ： 其实我觉得，珂朵莉和ODT的命运真的很像。特别是剧情如果这样，ODT在考场那一刻水过了一题（虽然实际是一场CF）。ODT能在考场上，就像珂朵莉在战场上，绽放此时此刻的光辉。然而，ODT，在考场水过的那一刻，就是死的那一刻。毕竟后人会卡。不管怎么说，ODT是世界上最幸福的数据结构</p>
</li>
<li>
<p>只是想说这本小说太沉重了，温馨中穿插着现实的无奈，相爱却又无法实现的恋情，在这里爱情显得更加沉重且又如此悲伤，最后只是要自已爱的人活下去都是一种奢望，在如此现实且残酷的事实面前，这个故事注定是一个悲剧，伴随着淡淡的忧伤的悲剧...（2017.4.26）</p>
</li>
<li>
<p>在激情的节奏中弥漫着淡淡的忧伤，正如动漫和原作中欢快中流淌的悲伤，不矫情，不做作，人物的喜怒哀乐一举一动都触动着我的心，我想，这大概就是我喜欢这个作品的原因吧…希望威廉和珂朵莉最后能够走向HE（2017.4.26）</p>
</li>
<li>
<p>贴吧来的！希望动画不要把五卷全部做完！太敢了！（2017.4.27）</p>
</li>
<li>
<p>怎么说呢，虽然只是从当初的pv才了解了这部番，但是仅仅只有一个pv却吸引了我去看起了小说，虽然去感受这部作品的途中的自己哭的痛彻心扉，那时候曾如灰色世界般毫无生气，但是当我看完结局时，知道吗？那份救赎或许会给你带来我们一直在作品中想要寻求的那份奇迹哦？那份感动在我看来非常的耀眼。</p>
</li>
<li>
<p>比较喜欢的四月番，b站没买真是太好了<sup>o</sup>（2017.4.29）</p>
</li>
<li>
<p>原作是一本除了标题完全不像轻小说的轻小说，文笔细腻，把一般作品用在堆设定的篇幅都花在了对环境和心理细节的描写，更接近严肃文学。剧情和设定上说不上太有突破性，算是对05年左右正剧轻小说普遍低落展开的一次复辟，不过结合本身优秀的文风，读起来别有一番风味。这次的TV版制作组非常充分的把握住了原作的优点，并没有把受众定位为萌豚，分镜和音乐结合营造出的氛围都更接近于剧场动画。作画也十分优秀，上色很有层次感。顺带一提，田所梓的声线就是我想象中的&quot;普通的女孩子&quot;的声线，珂朵莉也是个普通的女孩子，所以我觉得非常合适。</p>
</li>
<li>
<p>在妖精少女故作坚强的外表下隐藏的是渴望被爱的脆弱内心，对威廉的喜欢最初或许确实只是憧憬、但是随着两人间的亲近心意与生离死别，那份喜欢确确实实的变为了铭刻在身上的爱。多希望op里最后的那个画面里珂朵莉能够不用哭泣，而是能够在不带一丝悲伤的笑容下，对威廉说出DEAREST DROP</p>
</li>
<li>
<p>黄油蛋糕这个灭世大flag就这样拔掉了真可惜，江湖从此又少了一个梗了（2017.5.10）</p>
</li>
<li>
<p>终于出了！那个剑与魔法的斯卡菠萝集市！当时配合着夕阳暖暖的色调，音乐响起的瞬间就惊了。经典就是听了无数次，当她再次响起时候一瞬间所有的细胞都被再次激活。这次的改曲比起最早的空灵更多了一份激荡人心（听说叫凯尔特风？） Then she'll be a true love of mine. 她会成为我的挚爱。（没错，就是斯卡菠萝）</p>
</li>
<li>
<p>这个故事的作者其实是在传递自己的幸福观——通过珂朵莉的选择来实践，通过紫发妖精兰的说教来总结。我们最后的哭泣，其实也是两重心境：一是哭剧情，哭男女主相爱不能相守；二也是哭自身，哭自己在俗世间随波逐流，羡慕女主能找到并且坚守自己真正的幸福。兰结尾的话，其实正是说给我们听的。</p>
</li>
<li>
<p>这部番的所有幸福、欢笑、悲痛与遗憾都凝结在这首歌里了，开头与结尾的前后呼应，借由一喜一悲的两个场景，更加强了这首歌在片里的感染力，岂可休，作者我要给你寄刀片</p>
</li>
<li>
<p>以往片子的女主总会有“这个我喜欢，这个我老婆”之类的宣言，但是这番却是我第一次有一种“我喜欢珂朵莉，我想祝她幸福”的感想，当初看小说也是如此，动画演绎的很棒</p>
</li>
<li>
<p>大家都说这部动漫这个故事很悲伤，但我觉得这里面悲伤的情节都不重要，我就喜欢就记得珂朵莉在威廉面前的笑容、害羞、吃醋等等的一个个画面。可能珂朵莉也正是这样，眼中只有和威廉曾经有过的幸福温馨的时光，觉得自己是最幸福的女孩。</p>
</li>
<li>
<p>（Always in my heart）贯穿了整剧的音乐，不论是开头的空灵惊艳，还是中间的煽情变奏，亦或是最后12集听到时感受到的那份浓浓的伤感，为珂朵莉量身打造的歌词也早就预示着无法回避的结局。但至少我知道，她是世上最幸福的女孩！</p>
</li>
<li>
<p>歌声响起，珂朵莉在夕阳中纵身跃下飞船的画面就会在我脑海展开 正如歌名，always in my heart，虽不能陪你到老，但那些经历过的美好瞬间，永在心中 所以，“现在的我，一定是全世界最幸福的女孩”</p>
</li>
<li>
<p>沐浴着金色夕阳的云层上方，风撩动着少女仅剩的几丝蓝发，少女心中勉强还存留着的“珂朵莉”对连自己是谁都已经迷失，却依然残存着最后的心愿的她诉说着：现在的她，无论别人怎么说，都一定是世界上，最幸福的女孩。那遍体鳞伤的黑发青年，是她不惜将余下的生命全部燃尽也要守护的人，她爱他。</p>
</li>
<li>
<p>很少可以碰见这么好好讲故事的一部轻小说，悲伤而又不做作，它描述的爱情美丽而自然，祝愿每个世界，世界每个角落的人都能这样爱过</p>
</li>
<li>
<p>正因为得知了威廉和珂朵莉此身此世的艰难，他们那努力的去焕发着希望和温暖的精神，他们那真挚的祈求着生命的光辉此刻直冲心灵。正因为他们所想要诉说的情感是这么深刻，幸福，两个这么简单的字。此刻我也终于可以去回应他们，这份爱至今犹存。</p>
</li>
<li>
<p>人生，不是为了比较事物 所以我持有光明和阴影 星空闪耀的光芒会将我带到你身边 穿越黑夜，我看到被照亮的道路 我不知道什么样的生活方式才是正确的 但我知道我爱的真理 如果一切都是命中注定 这条我该用尽一生行进的路 我发誓不论如何，我都将前往 我将会把我所拥有的这样的恩典永留我的心中</p>
</li>
<li>
<p>追完番后发现还是开头最打动我，在夕阳的余辉下，伴随这首Always in my heart,珂朵莉慢慢走向船尾，诉说着她的内心。那是一种从最开始就注定短暂又美好的悲伤，唉</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML学习笔记 1]]></title>
        <id>https://chtholist.gitee.io/post/HTMLstudy1/</id>
        <link href="https://chtholist.gitee.io/post/HTMLstudy1/">
        </link>
        <updated>2020-03-22T03:21:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="html">HTML</h1>
<h2 id="html简介">HTML简介</h2>
<ol>
<li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li>
<li>HTML 不是一种编程语言，而是一种标记语言</li>
<li>标记语言是一套标记标签</li>
<li>HTML文档(网页) = 标记标签 + 纯文本  (使用标记标签来描述网页)</li>
</ol>
<h4 id="html-标签">HTML 标签</h4>
<p>由尖括号包围的关键词</p>
<ul>
<li>通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;</li>
<li>标签对中的第一个标签是开始标签(开放标签)，第二个标签是结束标签(闭合标签)</li>
</ul>
<h4 id="html元素">HTML元素</h4>
<ul>
<li>元素内容 = 开始标签到结束标签间的内容</li>
<li>空元素在开始标签中关闭 （以开始标签的结束而结束）<br>
&lt;br&gt; 为没有关闭标签的空元素（定义换行）<br>
在开始标签中添加斜杠 —&gt; 关闭空元素   （如&lt;br/&gt;）</li>
</ul>
<h4 id="html属性">HTML属性</h4>
<ul>
<li>属性为 <code>名称 = &quot;值&quot;</code></li>
<li>属性在开始标签中规定</li>
</ul>
<h4 id="html输出">HTML输出</h4>
<ul>
<li>无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。</li>
<li>无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。</li>
<li>当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。</li>
</ul>
<hr>
<hr>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;             
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 让网页可以显示中文 --&gt;
        &lt;title&gt; 网页名称 &lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        正文……
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;!DOCTYPE html&gt;</td>
<td style="text-align:center">声明为 HTML5 文档(不分大小写)</td>
</tr>
<tr>
<td style="text-align:center">&lt;html&gt;</td>
<td style="text-align:center">HTML 页面的根元素，之间的文本描述网页</td>
</tr>
<tr>
<td style="text-align:center">&lt;head&gt;</td>
<td style="text-align:center">包含了文档的元（meta）数据，如 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式为 utf-8。</td>
</tr>
<tr>
<td style="text-align:center">&lt;title&gt;</td>
<td style="text-align:center">描述了文档的标题</td>
</tr>
<tr>
<td style="text-align:center">&lt;body&gt;</td>
<td style="text-align:center">之间的文本可见的页面内容</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;h1&gt;</td>
<td style="text-align:center">定义一个标题 ( h1-h6 )</td>
</tr>
<tr>
<td style="text-align:center">&lt;p&gt;</td>
<td style="text-align:center">定义一个段落</td>
</tr>
<tr>
<td style="text-align:center">&lt;hr/&gt;</td>
<td style="text-align:center">创建水平线</td>
</tr>
<tr>
<td style="text-align:center">&lt;!-- xxx --&gt;</td>
<td style="text-align:center">注释</td>
</tr>
<tr>
<td style="text-align:center">&lt;br/&gt;</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">&lt;hr/&gt;</td>
<td style="text-align:center">划分线</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">文本设置</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;b&gt; or &lt;strong&gt;</td>
<td style="text-align:center">加粗文本</td>
</tr>
<tr>
<td style="text-align:center">&lt;em&gt;  or &lt;i&gt;</td>
<td style="text-align:center">斜体文本</td>
</tr>
<tr>
<td style="text-align:center">&lt;big&gt;</td>
<td style="text-align:center">放大文本</td>
</tr>
<tr>
<td style="text-align:center">&lt;small&gt;</td>
<td style="text-align:center">缩小文本</td>
</tr>
<tr>
<td style="text-align:center">&lt;sub&gt;</td>
<td style="text-align:center">下标</td>
</tr>
<tr>
<td style="text-align:center">&lt;sup&gt;</td>
<td style="text-align:center">上标</td>
</tr>
<tr>
<td style="text-align:center">&lt;del&gt;</td>
<td style="text-align:center">删除线</td>
</tr>
<tr>
<td style="text-align:center">&lt;ins&gt;</td>
<td style="text-align:center">下划线</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">计算机输出</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;code&gt;</td>
<td style="text-align:center">定义计算机代码</td>
</tr>
<tr>
<td style="text-align:center">&lt;kbd&gt;</td>
<td style="text-align:center">定义键盘码</td>
</tr>
<tr>
<td style="text-align:center">&lt;samp&gt;</td>
<td style="text-align:center">定义计算机代码样本</td>
</tr>
<tr>
<td style="text-align:center">&lt;tt&gt;</td>
<td style="text-align:center">定义打字机代码</td>
</tr>
<tr>
<td style="text-align:center">&lt;var&gt;</td>
<td style="text-align:center">定义变量</td>
</tr>
<tr>
<td style="text-align:center">&lt;pre&gt;</td>
<td style="text-align:center">定义预格式文本</td>
</tr>
</tbody>
</table>
<ul>
<li>code 元素不保留多余的空格和折行</li>
</ul>
<pre>
    使用pre显示预格式文本
        可以保留
            空格和换行
                适合显示代码
</pre>
<table>
<thead>
<tr>
<th style="text-align:center">引用 &amp; 术语定义</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;address&gt;</td>
<td style="text-align:center">定义地址</td>
</tr>
<tr>
<td style="text-align:center">&lt;bdo dir=&quot;rtl&quot;&gt;</td>
<td style="text-align:center">定义文字方向(逆序)</td>
</tr>
<tr>
<td style="text-align:center">&lt;blockquote&gt;</td>
<td style="text-align:center">定义长的引用 (浏览器会插入换行和外边距)</td>
</tr>
<tr>
<td style="text-align:center">&lt;q&gt;</td>
<td style="text-align:center">定义短的引用语(仅添加引号)</td>
</tr>
<tr>
<td style="text-align:center">&lt;cite&gt;</td>
<td style="text-align:center">定义引用、引证</td>
</tr>
<tr>
<td style="text-align:center">&lt;dfn&gt;</td>
<td style="text-align:center">定义一个定义项目</td>
</tr>
</tbody>
</table>
<ul>
<li><bdo dir="rtl"> 使用 bdo dir=&quot;rtl&quot; 更改文字方向</bdo><br>
<code>&lt;bdo dir=&quot;rtl&quot;&gt; 使用 bdo dir=&quot;rtl&quot; 更改文字方向&lt;/bdo&gt;</code></li>
</ul>
<hr>
<hr>
<h2 id="链接">链接</h2>
<p>用标签&lt;a&gt;&lt;/a&gt; (在href这个属性中指定链接的地址url)<br>
<a href="https://chtholist.github.io" target="_blank" > 这是一个链接 </a><br>
<code>&lt;a href=&quot;url&quot; target=&quot;_blank&quot; &gt; 链接的替代文字 &lt;/a&gt;</code></p>
<ul>
<li>target=&quot;_blank&quot; —&gt; 让链接在新窗口打开</li>
</ul>
<h4 id="命名锚">命名锚</h4>
<p>命名锚：HTML页面中的书签 （同页面内跳转），这样浏览者就不用滚动页面<br>
<code>&lt; a href=&quot;#tip&quot; &gt; 命名锚从这里跳转 &lt;/a&gt;</code><br>
<code>&lt;a name=&quot;tip&quot;&gt; 命名锚跳转到这里 &lt;/a&gt;</code></p>
<ul>
<li>命名锚跳转的地方，用 #+锚名 来链接，可添加到URL的末端</li>
</ul>
<h4 id="跳出框架">跳出框架</h4>
<p><code>&lt;a href=&quot;这个网页的url&quot; target=&quot;_top&quot;&gt; 替代文字 &lt;/a&gt;</code></p>
<h4 id="去掉链接的下划线">去掉链接的下划线</h4>
<pre><code class="language-js">&lt;style&gt;
    a{TEXT-DECORATION:none}                         /*去掉超链接的下划线*/
    a:hover{TEXT-DECORATION:underline}      /*当鼠标移上去时出现下划线*/
&lt;/style&gt;
</code></pre>
<hr>
<hr>
<h2 id="图像">图像</h2>
<p>用标签&lt;img src=&quot; &quot;&gt;<br>
<code>&lt;img src=&quot;url&quot; width=&quot;x&quot; height=&quot;y&quot; alt=&quot;图片显示不出来时替换的文本&quot; align=&quot; bottom / middle / top / left / right (对齐方式)&quot; /&gt;</code></p>
<ul>
<li>图像作为链接：</li>
</ul>
<pre><code class="language-html">    &lt;a href=&quot;要跳转到的url&quot; &gt;
        &lt;img border=&quot;0&quot; src=&quot;图片的url&quot; &gt;
    &lt;/a&gt;
</code></pre>
<h4 id="图片映射">图片映射</h4>
<pre><code class="language-html">&lt;img src=&quot;url&quot; usemap=&quot;#PhotoName&quot;&gt;
&lt;map name=&quot;PhotoName&quot;&gt;
  &lt;area shape=&quot;rect&quot; coords=&quot;x1,y1,x2,y2&quot;  href=&quot;url1&quot;&gt;
  &lt;area shape=&quot;circle&quot; coords=&quot;x1,y1,r&quot;  href=&quot;url2&quot;&gt;
&lt;/map&gt;
</code></pre>
<ul>
<li>shape指点击区域的形状，coords指链接区域在图中的坐标（像素为单位）
<ul>
<li>矩形rect：左上角顶点坐标为(x1,y1)，右下角顶点坐标为(x2,y2)</li>
<li>圆形circle：圆心坐标为(X1,y1)，半径为r</li>
<li>多边形：各顶点坐标依次为(x1,y1)、(x2,y2)、(x3,y3) ......</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h2 id="字体">字体</h2>
<ul>
<li>用 style=&quot; xxx : xxx ;&quot; 设置</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字体</td>
<td style="text-align:center">font-family</td>
</tr>
<tr>
<td style="text-align:center">字体大小</td>
<td style="text-align:center">font-size</td>
</tr>
<tr>
<td style="text-align:center">背景颜色</td>
<td style="text-align:center">background-color</td>
</tr>
<tr>
<td style="text-align:center">文本对齐方式</td>
<td style="text-align:center">text-align</td>
</tr>
</tbody>
</table>
<h4 id="缩写文本">缩写文本</h4>
<p>把鼠标移至缩略词语上时，可展示完整版本<br>
<abbr title="使用abbr显示缩写"> 缩 </abbr><br>
<code>&lt;abbr title=&quot;使用abbr显示缩写&quot;&gt; 缩 &lt;/abbr&gt;</code><br>
<acronym title="World Wide Web"> WWW </acronym><br>
<code>&lt;acronym title=&quot;使用acronym显示首字母缩写&quot;&gt; 首缩 &lt;/acronym&gt;</code></p>
<hr>
<hr>
<h2 id="样式表">样式表</h2>
<p>所有的格式化代码均可移出 HTML 文档，然后移入一个独立的样式表<br>
当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化。</p>
<ul>
<li>将CSS添加到HTML中：
<ul>
<li><strong>内联样式</strong>：在HTML元素中使用 style <em>属性</em></li>
<li><strong>内部样式表</strong>：在HTML文档头部 head 区域中用 style <em>元素</em>来包含CSS</li>
<li><strong>外部引用</strong>：使用外部CSS文件</li>
</ul>
</li>
</ul>
<h4 id="内联样式h3">内联样式</h3></h4>
<ul>
<li>当特殊的样式需要应用到<strong>个别元素</strong>时，就可以使用内联样式。</li>
<li>使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何CSS 属性。<br>
<code>&lt;p style=&quot;color:blue;&quot;&gt; 使用内联样式 &lt;/p&gt;</code></li>
</ul>
<h4 id="内部样式表">内部样式表</h4>
<ul>
<li>当<strong>单个文件</strong>需要特别样式时，就可以使用内部样式表。</li>
<li>可以在 head 部分通过 style 标签定义内部样式表。</li>
</ul>
<h4 id="外部样式表-推荐">外部样式表 （推荐）</h4>
<ul>
<li>当样式需要被应用到<strong>很多页面</strong>的时候，外部样式表将是理想的选择。</li>
<li>可以通过更改一个文件来改变整个站点的外观。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java&后端 学习路径]]></title>
        <id>https://chtholist.gitee.io/post/JAVAstudy0/</id>
        <link href="https://chtholist.gitee.io/post/JAVAstudy0/">
        </link>
        <updated>2020-03-22T03:20:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="后端学习">后端学习</h1>
<h2 id="基础篇">基础篇</h2>
<h3 id="java">Java</h3>
<ol>
<li>环境及基础语法（重点在于数据类型、类与对象、文件、异常等操作）：<br>
https://www.runoob.com/java/java-tutorial.html</li>
<li>servlet——java web基础（重点在于http，session，cookie，数据库访问，文件上传等）：<br>
https://www.runoob.com/servlet/servlet-writing-filters.html</li>
</ol>
<h3 id="mysql">Mysql</h3>
<p>数据库各种基本操作：https://www.runoob.com/mysql/mysql-tutorial.html</p>
<h3 id="git">Git</h3>
<p>菜鸟教程：https://www.runoob.com/git/git-basic-operations.html<br>
廖雪峰：https://www.liaoxuefeng.com/wiki/896043488029600</p>
<h3 id="maven">Maven</h3>
<p>菜鸟教程（重点在于仓库配置，部署，理解，mvn打包命令）：<br>
https://www.runoob.com/maven/maven-tutorial.html</p>
<h2 id="入门篇">入门篇</h2>
<h3 id="spring">Spring</h3>
<p>配置及基础概念：https://www.w3cschool.cn/wkspring/</p>
<h3 id="mybatis">Mybatis</h3>
<p>文档：https://mybatis.org/mybatis-3/zh/index.html</p>
<h3 id="redis">Redis</h3>
<p>数据类型文档：https://redis.io/topics/data-types-intro</p>
<h3 id="springboot">Springboot</h3>
<p>项目学习：https://github.com/MarkLux/today</p>
<h2 id="实战篇">实战篇</h2>
<ul>
<li>初级 简单用户demo</li>
<li>中级 xxx</li>
<li>高级 xxx<br>
实战篇初级要求：基础篇和入门篇所有知识点都有一定掌握程度</li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="开发工具">开发工具</h3>
<ul>
<li>IDEA（Java）</li>
<li>Navicat（Mysql）</li>
<li>Postman（http模拟请求）</li>
<li>Git</li>
</ul>
<h3 id="网站">网站</h3>
<ul>
<li>慕课网（只建议学习免费视频）：https://www.imooc.com/course/list</li>
<li>程序园（里面东西很多，如果不清楚学习顺序可以先向学长询问）：http://www.voidcn.com/course</li>
<li>牛客（剑指Offer 刷算法题）：https://www.nowcoder.com/ta/coding-interviews</li>
</ul>
<hr>
<hr>
<h1 id="java学习">Java学习</h1>
<ul>
<li>面向对象的编程思想</li>
<li><u><strong>数据类型 / 类与对象 / 文件 / 异常处理</strong></u></li>
<li>数组</li>
<li>数据结构与算法</li>
<li>集合：List &amp; Map</li>
<li>代码管理：SVN / <strong><u>Git</u></strong></li>
<li>Java项目管理工具：  Gradle / <strong><u>Maven(仓库配置，部署，理解，mvn打包命令)</u></strong></li>
</ul>
<h2 id="web相关">Web相关</h2>
<ul>
<li>网络模型/网络协议</li>
<li><u><strong>了解servlet——http，session，cookie，数据库访问，文件上传</strong></u></li>
<li>写一个B/S的demo</li>
</ul>
<h2 id="数据库">数据库</h2>
<ul>
<li><strong><u>MySQL</u></strong> ACID</li>
<li>学业务建模 写SQL</li>
<li>使用JDBC，写带数据库的demo</li>
</ul>
<h2 id="基本语法-常用jdk-api">基本语法 &amp; 常用JDK API</h2>
<ul>
<li>一些简单的带有逻辑的算法题</li>
<li>一些多编程读写文件的demo</li>
<li>一些具有多继承 多态性质的demo</li>
</ul>
<h2 id="框架">框架</h2>
<ul>
<li>Spring SSM框架</li>
<li>了解前后端分离，编写Restful接口</li>
<li>使用框架搭建后端，写一个前后端分离的demo</li>
</ul>
<hr>
<ol>
<li>零基础开始学java，到多线程为止</li>
<li>对JAVA有了一定的基础之后，就可以看JSP的知识，也就是JAVA跟web前台页面联合起来用。JSP需要一点html网页的基础</li>
<li>
<ul>
<li>在学JSP的时候，会接触到javaScript 俗称js。不难，照着网站学一下就行。</li>
<li>在学JSP的时候，会接触到MVC分层， M--Model就是JavaBean也就是一种符合一定规范的Java类，V--View就是视图也就是前台显示的东西，C--Controller就是控制器也就是Servlet之类是通过写一些方法来沟通Model与View之间的交互；</li>
</ul>
</li>
<li>JSP相关知识掌握好后，那可以看一下框架相关的东西，SSH、SSM框架是现在用得比较多的框架</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java —— 最基础]]></title>
        <id>https://chtholist.gitee.io/post/JAVAstudy1/</id>
        <link href="https://chtholist.gitee.io/post/JAVAstudy1/">
        </link>
        <updated>2020-03-22T03:19:10.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>JavaSE (Java标准版)</li>
<li>JavaEE (Java企业版)</li>
<li>JavaME (Java微型版)<br>
JavaSE为基础，JavaEE为方向</li>
</ol>
<ul>
<li>JDK：Java开发工具包 （一般自带JRE）
<ul>
<li>Java程序设计语言</li>
<li>JRE：Java的运行环境
<ul>
<li>JVM：Java虚拟机</li>
<li>Java API类库</li>
</ul>
</li>
<li>各种辅助工具，如javac</li>
</ul>
</li>
</ul>
<hr>
<h2 id="java简介">Java简介</h2>
<ul>
<li>简单性：
<ul>
<li>Java语言底层是C++实现的</li>
<li>Java不支持多继承</li>
<li>Java屏蔽了指针的概念</li>
</ul>
</li>
<li>Java纯面向对象，所有代码写在类中</li>
<li>可移植性
<ul>
<li>Java程序可跨平台直接在windows和Linux上运行，不用做修改<br>
（让Java程序运行在不同版本的Java虚拟机JVM上）</li>
</ul>
</li>
<li>多线程</li>
<li>健壮性：
<ul>
<li>运行过程中产生的垃圾自动回收，自动垃圾回收机制——GC机制</li>
<li>c++中开辟空间后要再人为释放，Java中只需要申请空间不需要回收</li>
</ul>
</li>
</ul>
<hr>
<h2 id="java-的加载-执行">Java 的加载 &amp; 执行</h2>
<p>（DOS命令）</p>
<h3 id="编译">编译</h3>
<ul>
<li>源文件( .java )编译生成一个或多个字节码文件( .class )</li>
<li>字节码文件 / class文件为最终运行的文件</li>
<li>class文件名 = <strong>类名</strong></li>
<li>JDK工具包里有Java编译器（命令）javac.exe<br>
javac.exe将源文件编译成字节码文件</li>
</ul>
<h3 id="运行">运行</h3>
<ul>
<li>把DOS窗口的路径切换到字节码文件所在的目录（dir能看到文件）<br>
输入Java x （x.class）  (Java后面跟着类名)<br>
java.exe命令会启动JVM，启动类加载器ClassLoader<br>
ClassLoader会去硬盘上搜索 x.class 文件，装载到JVM中<br>
（classpath环境变量属于Java语言，配置为某个指定路径之后，类加载器只去指定的路径中加载字节码文件）（若未配则从当前路径下加载）<br>
JVM将 x.class 文件解释成二进制数据<br>
操作系统执行二进制和底层硬件平台交互</li>
</ul>
<hr>
<h3 id="注释">注释</h3>
<ul>
<li>只会出现在Java的源程序.java中，不会被编译到字节码.class中</li>
<li><u><strong>javadoc注释（会被javadoc.exe提取到java的帮助文档中）</strong></u><br>
/**<br>
*  javadoc1<br>
*  javadoc2<br>
*/</li>
</ul>
<hr>
<pre><code class="language-java">public class HelloWorld {
  public static void main( String[] args) {   //定义一个公开的静态的主方法
    System.out.println(&quot;Hello World&quot;);
  }
}  
// ( String[] args )为一个main方法的形式参数列表
</code></pre>
<ul>
<li>类名和文件名必须一致（HelloWorld）</li>
</ul>
<hr>
<ol>
<li><strong>关键字</strong> ： 完全小写字母 /</li>
<li><strong>标识符</strong> ： <kbd>英文字母（大小写）</kbd> <kbd>数字</kbd> <kbd>$</kbd> <kbd>_</kbd><br>
（标识符不能以数字开头）
<ul>
<li>类名：首字母大写，后面每个单词首字母大写（大驼峰）</li>
<li>变量名：首字母<strong>小</strong>写，后米娜每个单词首字母大写（小驼峰）</li>
</ul>
</li>
<li>常量
<ul>
<li>Java的字符常量可以为中文  ：  &quot;汉&quot;</li>
</ul>
</li>
</ol>
<hr>
<h2 id="数据类型">数据类型</h2>
<ul>
<li>基本数据类型  (java中默认整型int，默认浮点型double)
<ul>
<li>整数型 ：byte (1字节，-128~127) / short (2字节) / int (4个字节) /long (8个字节)</li>
<li>浮点型 ：float (4个字节) / double (8个字节)</li>
<li>字符型 ：char (2个字节)</li>
<li>布尔型 ：<strong>boolean</strong> (1个字节)<br>
<strong>(数据大时， float和double类型后缀为F，long类型后缀为L )</strong></li>
</ul>
</li>
<li>引用数据类型
<ul>
<li><strong>字符串</strong></li>
<li>数组</li>
<li>类</li>
<li>接口</li>
<li>Lambda</li>
</ul>
</li>
</ul>
<p>(数据范围和字节数不一定相关，例如float范围比long广泛)</p>
<ul>
<li>隐式（自动）转换是<strong>数据范围</strong>从小到大
<ul>
<li>错： int num = 100L;</li>
<li>对： int num = (int)100L;</li>
</ul>
</li>
</ul>
<hr>
<h2 id="运算">运算</h2>
<h3 id="加法">加法</h3>
<ul>
<li>char / byte / short  + int<br>
在计算前char提升成int，根据ASCII码计算</li>
<li>String + 任何数据类型<br>
相加表示字符串连接，最终结果都是字符串<br>
<code>String str =&quot;abc&quot;;</code><br>
<code>System.out.println(str+10+20); //java1020</code><br>
<code>System.out.println(str+(10+20)); //java30</code></li>
</ul>
<pre><code class="language-java">short a = 5;
short b = 9;
short c1 = a+b;  //错误，不兼容的类型
//short + short ——&gt; int + int ——&gt; int
//正确的为 int c1 = a+b; 
short c2 = 5 + a + 8; //错误，右侧有变量  
</code></pre>
<hr>
<h2 id="方法">方法</h2>
<ul>
<li>主方法：<br>
public static void main(String[ ] args){……}</li>
<li>定义方法：<br>
public static 数据类型 方法名(){……}</li>
</ul>
<hr>
<h2 id="idea">IDEA</h2>
<h3 id="项目结构">项目结构</h3>
<ul>
<li>代码保存层次<br>
项目Project ——&gt; 模块Module ——&gt; 包Package ——&gt; 文件</li>
</ul>
<blockquote>
<p>File ——&gt; New ——&gt; Empty Project ——&gt; Add New Modules<br>
src ——&gt; New ——&gt; Package<br>
Package ——&gt; New ——&gt; Java Class<br>
调字体：File ——&gt; Settings ——&gt; Editor ——&gt; Font<br>
导入模块：File ——&gt; Project Structure ——&gt; Import Module</p>
</blockquote>
<ul>
<li>
<p>Package命名使用英文小写，数字和 <strong>&quot;.&quot;</strong><br>
按点给包分层：大包.中包.小包</p>
</li>
<li>
<p><strong>所有代码要写在src文件夹里</strong><br>
.iml为Idea的配置信息<br>
External Libraries 为JDK</p>
</li>
<li>
<table>
<thead>
<tr>
<th style="text-align:left">快捷输入</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">psvm回车</td>
<td style="text-align:left">——&gt; public static void main(String[] args){ }</td>
</tr>
<tr>
<td style="text-align:left">sout回车</td>
<td style="text-align:left">——&gt; System.out.println();</td>
</tr>
<tr>
<td style="text-align:left">n.fori回车</td>
<td style="text-align:left">——&gt;  for( int i=0; i&lt;5; i++ ) <strong>正序</strong></td>
</tr>
<tr>
<td style="text-align:left">n.forr回车</td>
<td style="text-align:left">——&gt;  for( int i=3; i&gt;0; i-- ) <strong>倒序</strong></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Alt + Enter</td>
<td style="text-align:center">自动修正代码</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + y</td>
<td style="text-align:center">删除当前行</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + d</td>
<td style="text-align:center">复制当前行到下一行</td>
</tr>
<tr>
<td style="text-align:center"><strong>Ctrl + Alt + L</strong></td>
<td style="text-align:center"><strong>格式化代码（对齐）</strong></td>
</tr>
<tr>
<td style="text-align:center">Ctrl + /</td>
<td style="text-align:center">当前行变为注释or取消注释</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + /</td>
<td style="text-align:center">选中代码注释/**/or取消注释</td>
</tr>
<tr>
<td style="text-align:center">Alt + Ins</td>
<td style="text-align:center">自动生成代码</td>
</tr>
<tr>
<td style="text-align:center">Alt +Shift +上下箭头</td>
<td style="text-align:center">移动当前行代码</td>
</tr>
<tr>
<td style="text-align:center">Alt + 鼠标左键选择</td>
<td style="text-align:center">上下列</td>
</tr>
</tbody>
</table>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">System.out.println(……);</td>
<td style="text-align:left">输出后换行</td>
</tr>
<tr>
<td style="text-align:left">System.out.print(……);</td>
<td style="text-align:left">输出后不换行</td>
</tr>
<tr>
<td style="text-align:left">System.out.println();</td>
<td style="text-align:left">换行</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="debug">Debug</h2>
<ul>
<li>Debug模式：Shift + F9</li>
<li>断点：在左边行号栏 单击左键 / Ctrl + F8</li>
<li>按蓝色向下箭头 / F7</li>
</ul>
<hr>
<h2 id="数组">数组</h2>
<ul>
<li>
<p>初始化  (左右数据类型要一致)</p>
<ul>
<li><strong>动态初始化（指定长度）</strong><br>
数据类型[ ] 数组名称 = new 数据类型[数组长度];<br>
int[] arrayA = new int [3];</li>
<li><strong>静态初始化（指定内容）</strong><br>
数据类型[ ] 数组名称 = new 数据类型[]{元素1, 元素2, ……};<br>
int[] arrayB = new int[]{2,5,6};</li>
<li><strong>省略格式静态初始化</strong><br>
数据类型[] 数组名称 = {元素1, 元素2, ……};</li>
</ul>
</li>
<li>
<p>直接打印数组名称，得到数组对应的内存地址哈希值</p>
</li>
</ul>
<hr>
<h2 id="java内存-数组">Java内存 &amp; 数组</h2>
<ol>
<li><strong>栈Stack</strong>：存放方法中的局部变量，<strong>方法一定在栈中运行</strong>  ，超出作用域即从栈内存中消失</li>
<li><strong>堆Heap</strong>：<strong>new出来的变量都在堆内存中</strong>，（数组都在堆中），都有16进制的地址值<br>
     堆内存中数据默认值
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整数</td>
<td style="text-align:center">浮点数</td>
<td style="text-align:center">字符</td>
<td style="text-align:center">布尔</td>
<td style="text-align:center">引用</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">\u0000</td>
<td style="text-align:center">false</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
</li>
<li><strong>方法区Method Area</strong>：存储.class相关信息，包含方法的信息</li>
<li>本地方法栈Native Method Stack：与操作系统相关</li>
<li>寄存器pc Register：与CPU相关</li>
</ol>
<pre><code class="language-java">public static void main ( String[ ] args){
  int[] array = new int [3];  
  System.out.println(array);     //直接打印地址值
  System.out.println(array[1]);  //根据栈中地址值找到堆中的数组
}
</code></pre>
<blockquote>
<p>1.方法区保存.class中的方法信息<code>public static void main(String[] args)</code><br>
2.运行main方法时将<code>main(String[] args)</code>加载到栈中，并开辟一段内存空间 ——&gt; <strong>进栈</strong><br>
3.数组名称为局部变量在栈中 ，new出来的数组在堆中，栈中存储的实际为数组地址值</p>
</blockquote>
<ul>
<li>
<p>引用<br>
<code>int[] arrayB = arrayA;</code> //将arrayA数组的地址值赋值给arrayB数组</p>
</li>
<li>
<p>所有的引用类型变量，都可以赋值Null,代表其中什么都没有<br>
数组若只赋值null，会发生空指针异常NullPointerException</p>
</li>
<li>
<p>获取数组长度：<code>int len = array.length</code><br>
<strong>数组创建后，程序运行期间，长度不可改变</strong>（一个new新建一个数组）<br>
可以用来遍历数组<code>for(int i=0; i&lt;array.length; i++)</code></p>
</li>
<li>
<p><strong>数组作为方法参数</strong>：</p>
<pre><code class="language-java">public static void main( String[] args ){
  int[] array = {1,2,3};
  printArray(array);            //传参即传入数组地址值
} 
public static void printArray( int[] array ){
  System.out.println(array[1]);
}
</code></pre>
</li>
<li>
<p><strong>数组作为返回值（可以返回多个值）</strong></p>
<pre><code class="language-java">public static void main( String[] args){
  int[] result = cal(10,20);    //用另一个数组介绍
  System.out.println(result[0],result[1]);
}
public static int[] cal(int a,int b){
  int sum = a+b;
  int avg = sum/2;
  int[] array={sum,avg};
  return array;                 //返回的即数组地址值
} ```  
</code></pre>
</li>
</ul>
<p><u>数组作为方法的参数，传递的是数组地址值</u><br>
<u>数组作为方法的返回值，返回的是数组的地址值</u></p>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">成员变量</th>
<th style="text-align:center">局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义位置</td>
<td style="text-align:center">方法外部，直接写在类中</td>
<td style="text-align:center">方法内部</td>
</tr>
<tr>
<td style="text-align:center">作用范围</td>
<td style="text-align:center">整个类内</td>
<td style="text-align:center">方法中</td>
</tr>
<tr>
<td style="text-align:center">默认值</td>
<td style="text-align:center">有初始默认值</td>
<td style="text-align:center">无默认值</td>
</tr>
<tr>
<td style="text-align:center">内存位置</td>
<td style="text-align:center">堆内存</td>
<td style="text-align:center">栈内存</td>
</tr>
<tr>
<td style="text-align:center">生命周期</td>
<td style="text-align:center">对象创建—&gt;对象被回收</td>
<td style="text-align:center">方法进栈—&gt;方法出栈</td>
</tr>
</tbody>
</table>
<p><u><strong>面向对象三大特性：封装、继承、多态</strong></u></p>
<h3 id="封装">封装</h3>
<p>把执行某一步骤的代码封装起来，对外界不可见</p>
<ul>
<li>方法、private为封装</li>
<li>间接访问private成员变量，要定义一对Getter/Setter方法
<ul>
<li>Alt + Insert 快捷插入Getter和Setter</li>
<li>对于boolean，Getter方法为<strong>isXxx</strong>的形式，setXxx不变</li>
</ul>
<pre><code class="language-java">public class Person{
  String name;
  private int age;

  //有参数无返回  方法名：set+首字母大写的private变量
  public void setAge(int num){  //专门用于向age设置数据
    age = num; …………             //方法内控制输入的数据
  }
  //无参数有返回  方法名：get+首字母大写的private变量
  public int getAge(){  //专门获取age的数据
    return age;
  }
} 
</code></pre>
</li>
<li>当方法的局部变量和类的成员变量<strong>重名</strong>时，优先使用局部变量<br>
访问类的成员变量：<strong>this.成员变量名</strong> （一定是在方法内部）<br>
通过谁调用方法，谁就是this</li>
</ul>
<h3 id="构造方法">构造方法</h3>
<ul>
<li>专门用来创建对象的方法，用nex创建对象时就是在调用构造方法</li>
<li>只要编写构造方法，编译器不再生成默认构造方法</li>
<li>public 类名(参数类型 参数名称){<br>
方法体<br>
}</li>
</ul>
<pre><code class="language-java">public class Student{
  private String name;
  private int age;
  public Student(){   //没有void,无返回值
    //执行构造方法
  }
  Student stu1 = new Student();    //实例化对象=调用构造方法  
  /*
   public Student(String name,int age){   //全参构造
    this.name = name;
    this.age = age;
  }
  Student stu2 = new Student(&quot;张三&quot;,20)；
  */
}
</code></pre>
<blockquote>
<p>Alt +Insert —&gt; Constructor —&gt; 构造方法  (Select None 无参构造)</p>
</blockquote>
<ul>
<li>
<p>标准的类  ( Java Bean )</p>
<ol>
<li>所有成员变量都用private修饰</li>
<li>每个成员变量都要有Getter/Setter方法</li>
<li>编写一个无参数的构造方法</li>
<li>编写一个全参数的构造方法 (参数为所有成员变量)</li>
</ol>
</li>
<li>
<p><u><strong>分文件</strong></u><br>
<strong>在一个包Package底下，分多个类class，把变量和方法封装起来，最后再建一个Demo类，其中有主函数来调用其他的class</strong></p>
</li>
</ul>
<hr>
<h2 id="api-应用程序编程接口">API  —— 应用程序编程接口</h2>
<p>（类似于字典）</p>
<ol>
<li>打开帮助文档</li>
<li>点击显示，找到索引，在输入框中搜索</li>
<li>看包路径 (java.lang下的类不需要导包，其他都需要import……)</li>
<li>看类的解释和说明</li>
<li>看构造方法</li>
<li>使用成员方法 （方法摘要）</li>
</ol>
<blockquote>
<p>关键字都是小写的，Scanner和String开头大写，为JDK中的类<br>
只要不是基本类型，就是引用类型<br>
使用引用类型：</p>
<ol>
<li>导包  ——  import 包路径.类名称;<br>
若要使用的目标类和当前类在同一个包下，或为java.lang，则不用导包<br>
导包语句 import…… 写在 package 后面 class 前面</li>
<li>创建  ——  类名称 对象名 = new 类名称();</li>
<li>使用  ——  对象名.成员方法名()</li>
</ol>
</blockquote>
<h3 id="从键盘获取输入">从键盘获取输入</h3>
<ol>
<li>System.in 方法<br>
只能针对一个字符的获取  /  获取的只是char类型的</li>
</ol>
<pre><code class="language-java">  //import java.io.IOException; (Idea自动补上)
  try {
    char i = (char) System.in.read();
    System.out.println(&quot;Enter Char is:&quot; + i);
  } 
  catch (IOException e) {
    e.printStackTrace();
  }   
</code></pre>
<ol start="2">
<li>InputStreamReader和BufferedReader方法<br>
可以获取键盘输入的字符串</li>
</ol>
<pre><code class="language-java">    InputStreamReader is = new InputStreamReader(System.in);   
    //new构造InputStreamReader对象 
    BufferedReader br = new BufferedReader(is);   
    //拿构造的方法传到BufferedReader中 
    try{ //该方法中有个IOExcepiton需要捕获 
      String name = br.readLine(); 
      System.out.println(&quot;ReadTest Output:&quot; + name); 
    } 
    catch(IOException e){ 
      e.printStackTrace(); 
</code></pre>
<ol start="3">
<li><strong>Scanner类中的方法</strong><br>
可以获取键盘输入的字符串和int,float等类型数据</li>
</ol>
<pre><code class="language-java">    Scanner sc = new Scanner(System.in); //System.in为从键盘输入
    // sc 作为对象名可以调用以输入
    String name = sc.nextLine();  //读取字符串型输入 
    int age = sc.nextInt();    //读取整型输入 
    float salary = sc.nextFloat(); //读取float型输入 
    char x = sc.next().charAt(0)
    …………   
</code></pre>
<hr>
<h3 id="匿名对象-new-类名称">匿名对象 —— new 类名称();</h3>
<p>只有右边的对象，没有左边的名字和赋值运算符<br>
匿名对象只能使用一次 （无法调用）</p>
<blockquote>
<p>new Student().name = &quot;张三&quot;;</p>
</blockquote>
<p>只接受一个输入：<code>int num = new Scanner(System.in).nextInt();</code></p>
<pre><code class="language-java">//这个函数methodReturn相当于sc
public static Scanner methodReturn(){
  return new Scanner(System.in);  //匿名对象作为方法返回值
}
</code></pre>
<h3 id="random类-生成随机数">Random类  —— 生成随机数</h3>
<ol>
<li>导包： import java.util.Random;  （可自动生成）</li>
<li>创建： <code>Random r = new Random();</code></li>
<li>使用：<br>
<code>int num = r.nextInt(); // int范围内的伪随机数</code><br>
<code>int num = r.nextInt(n); // [0,n)范围内的伪随机数</code></li>
</ol>
<blockquote>
<p>求2~35直接的随机整数 ——&gt; <strong>r.nextInt(34)+2;</strong></p>
</blockquote>
<ul>
<li>生成指定位数的<strong>随机字符串</strong> (包含大小字母、数字,0&lt;length)<br>
1.先自定义一个字符串库KeyString<br>
2.通过Math.random()方法获取KeyString长度内的一个随机数<br>
3.再获取该随机数对应KeyString中相应位置的一个字符<br>
4.最后将随机获取并组装好的字符串返回。<br>
若想修改包含的字符,只需将相应字符添加到字符串库KeyString 中去即可<pre><code class="language-java">//获取随机字符串
public static String getRandomString(int length) {
  //随机字符串的随机字符库
  String KeyString = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
  StringBuffer sb = new StringBuffer();
  int len = KeyString.length();
  for (int i = 0; i &lt; length; i++) {
     sb.append(KeyString.charAt((int) Math.round(Math.random() * (len - 1))));
  }
  return sb.toString();
}
</code></pre>
</li>
</ul>
<h3 id="arrayliste">ArrayList&lt;E&gt;</h3>
<ul>
<li>数组长度不可以改变，ArrayList集合的长度可以随意变</li>
<li>&lt;E&gt;表示<strong>泛型</strong>：在集合中的所有元素均为统一的引用类型，不能为基本类型<br>
(集合中储存的为地址值，基本类型无地址值)</li>
<li>直接打印ArrayList得到的是内容，若无内容则得到“ [ ] ”</li>
</ul>
<pre><code class="language-java">public static void main(String[] args){
  ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
  //创建了一个ArrayList集合，名称为 list，装的是String字符串类型的数据  
  // ps.从JDK1.7+开始，右侧尖括号内可以不写内容  
  list.add(&quot;内容&quot;);   //添加数据要用到 add()  
  System.out.println(list);     //打印出  [内容]
}     
</code></pre>
<ul>
<li><code>public booleam add(E e)</code><br>
向集合中<strong>添加元素</strong>，参数的类型和泛型一致，返回值表示添加是否成功<br>
（对于ArrayList集合，add一定成功，可不用返回值，但其他集合的add不一定成功）</li>
<li><code>public E get(int index)</code><br>
从集合中<strong>获取元素</strong>，参数index为序号，返回值为对应序号的元素</li>
<li><code>public E remove(int index)</code><br>
从集合中<strong>删除元素</strong>，参数index为序号，返回值为被删除掉的元素</li>
<li><code>public int size()</code><br>
<strong>获取集合的长度</strong>，返回值为集合中元素的个数</li>
</ul>
<blockquote>
<p>list.fori ——&gt; for( int i = 0; i &lt; list.size(); i++){ }</p>
</blockquote>
<ul>
<li>
<p>若要在ArrayList中存储基本类型数据，要使用对应的包装类<br>
（包装类为引用类型，位于java.lang包下）</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center"><strong>Integer</strong></td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Double</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center"><strong>Character</strong></td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对象添加到集合</p>
</li>
</ul>
<pre><code class="language-java">ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();
Student stu = new Student(&quot;张三&quot;,15);
list.add(stu);
</code></pre>
<hr>
<h2 id="string">String</h2>
<ul>
<li>Java中所有字符串都为String类的对象（实例）</li>
<li>字符串的内容不可改变</li>
<li>字符串可以共享使用</li>
<li>字符串效果相当于char[] 字符数组，但<strong>底层原理为byte[]字节数组</strong></li>
</ul>
<h3 id="构造方法-2">构造方法</h3>
<ol>
<li><code>String str = &quot; …… &quot;</code><br>
直接创建 (直接写上双引号，就是字符串对象)</li>
<li><code>public String( )</code><br>
创建一个空白字符串，内容为null</li>
<li><code>public String( char[ ] array )</code><br>
根据字符数组的内容，合起来建立相应的字符串  (括号中为数组名)</li>
<li><code>public String( byte[] array )</code><br>
根据字节数组的内容，合起来建立相应的字符串  (括号中为数组名)
<blockquote>
<p>byte类型存储的全是ASCII码<br>
<code>byte val = 97;</code><br>
<code>System.out.println( (char) val);</code><br>
结果为：a</p>
</blockquote>
</li>
</ol>
<h3 id="常量池">常量池</h3>
<p>程序中只有直接写上的双引号字符串，才在字符串常量池中</p>
<ul>
<li>对于基本类型，== 为<strong>数值</strong>的比较</li>
<li>对于引用类型，== 为<strong>地址值</strong>的比较</li>
</ul>
<blockquote>
<p><code>String str = &quot;abc&quot;;</code><br>
堆 —&gt; 字符串常量池 —&gt; 字符串对象String —&gt; 保存byte[] = {97,98,99}的地址值<br>
栈 —&gt; String str 保存常量池中String 的地址值<br>
<a href="F:/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0.png">内存图</a></p>
</blockquote>
<h4 id="字符串比较">字符串比较</h4>
<p>（== 为对象地址值间的比较）</p>
<ul>
<li><code>public bollean equals ( Object obj );</code><br>
参数可以为任何对象，true &lt;——&gt; 参数为一个字符串&amp;&amp;内容相同<br>
若比较双方一个常量一个变量，应用 <code>常量.equals(变量)</code><pre><code class="language-java">String str1 = &quot;hello&quot;;
char[] charArray = {'h','e','l','l','o'};
String str2 = new String (charArray);
System.out.println( str1.equals(str2) );  //true
</code></pre>
</li>
<li><code>public boolean equalsIgnoreCase (String str);</code><br>
忽略大小写进行内容比较</li>
</ul>
<h4 id="字符串获取">字符串获取</h4>
<ul>
<li><code>public int Length();</code><br>
获取字符串长度</li>
<li><code>public String concat(String str);</code><br>
将当前字符串和参数字符串拼接成返回值新的字符串</li>
<li><code>public char charAt(int index);</code><br>
获取指定序号的单个字符</li>
<li><code>public int indexOf(String str);</code><br>
查找参数字符串在当前字符串中首次出现的序号， 无则返回-1</li>
</ul>
<pre><code class="language-java">String str1 =&quot;hello&quot;;
String str2 =&quot;world&quot;;

//获取长度 length()
System.out.println(str1.length());

//拼接 concat(String)
System.out.println(str2.concat(str1));

//通过序号查找字符 charAt(int)
System.out.println(str1.charAt(3));

//通过字符查找首次出现的序号 indexOf(char/String)
System.out.println(str2.indexOf('d'));
</code></pre>
<h4 id="字符串截取">字符串截取</h4>
<ul>
<li><code>public String substring(int index);</code><br>
从参数位置截取到字符串末尾，返回新字符串</li>
<li><code>public String substring(int begin, int end);</code><br>
从begin截取到end，返回截取的新字符串</li>
</ul>
<h4 id="字符串转换">字符串转换</h4>
<ul>
<li><code>public char[] toCharArray[]();</code><br>
将当前字符串拆分成字符数组作为返回值</li>
<li><code>public byte[] getBytes();</code><br>
获得当前字符串底层的字节数组</li>
<li><code>public String replace(CharSequence oldString, CharSequence newString)</code><br>
将所有出现的字符串替换成新字符串，返回新字符串</li>
</ul>
<pre><code class="language-java">String str = &quot;HelloWorld&quot;;  
//拆分为字符数组  
char[] char1 = str.toCharArray();
//拆分为字节数组  
byte[] bytes = str.getBytes();  
//字符串替换  
String str2 = str.replace(&quot;o&quot;,&quot;*&quot;);
System.out.println(str2);     //输出：Hell*W*rld   
</code></pre>
<h4 id="字符串分割">字符串分割</h4>
<ul>
<li><code>public String[] split(String regex);</code><br>
按照参数的规则，将字符串分割为若干部分<br>
split方法的参数为<strong>正则表达式</strong>，若按“.”切分要写“<strong>\ \ .</strong>”</li>
</ul>
<pre><code class="language-java">String array = &quot;aaa/bbb//c/d&quot;;
String[] split = array.split(&quot;/&quot;);
for (int i = 0; i &lt; split.length; i++) {
  System.out.print(&quot;(&quot;+(i+1)+&quot;)&quot;+split[i]);
}
// (1)aaa(2)bbb(3)(4)c(5)d 
</code></pre>
<blockquote>
<p>输入完 <code>array.split(&quot;/&quot;);</code> 后按 Alt+Enter 自动补充之前的 <code>String[] split =</code></p>
</blockquote>
<hr>
<h3 id="静态static关键字">静态static关键字</h3>
<p>只在类中保存一份，不属于对象，属于类，所有本类对象共享同一份</p>
<ul>
<li>对于<strong>静态方法/变量</strong>，可以通过对象名调用，也可<strong>通过类名调用</strong><br>
（用对象名调用时，JDK会自动转换成类名）</li>
<li>本类中的静态方法，调用时可省略类名称</li>
<li>静态方法不能直接访问非静态变量 （在内存中先有静态内容，后才有非静态）</li>
<li>静态方法中不能使用 this （this代表当前对象，用谁调用谁就是当前对象）</li>
</ul>
<h4 id="静态代码块">静态代码块</h4>
<ul>
<li>用途：一次性地对静态成员变量进行赋值</li>
</ul>
<pre><code class="language-java">public class 类名称{
  static {
    //静态代码块的内容
  }
}
</code></pre>
<ul>
<li>静态内容总是优先于非静态 ——&gt; 静态代码块比构造方法先执行</li>
<li>静态代码块只执行唯一的一次</li>
</ul>
<hr>
<h3 id="arrays-数组工具类">Arrays 数组工具类</h3>
<ul>
<li><code>public static String toString(数组);</code><br>
将参数数组变为字符串，按默认格式 [元素1,元素2……]<br>
(输出数组名只能得到地址值，所以可以先转成字符串)</li>
</ul>
<pre><code class="language-java">char[] array2 = {'h','e','l','l','o'};
System.out.println( Arrays.toString(array2) );
</code></pre>
<ul>
<li><code>public static void sort(数组)</code><br>
按默认升序对数组元素进行排序<br>
（若为自定义类型，需要有Comparable或Comparator接口的支持）</li>
</ul>
<pre><code class="language-java">int[] array = {2,1,3,10,6};
Arrays.sort(array);
System.out.println(Arrays.toString(array));
//  [1, 2, 3, 6, 10]
</code></pre>
<h3 id="math-数学工具类">Math 数学工具类</h3>
<ul>
<li>Math.PI / public static final double PI —&gt; 圆周率近似</li>
<li>public static double abs(double num) —&gt; 绝对值</li>
<li>public static double ceil(double num) —&gt; 向上取整</li>
<li>public static double floor(double num) —&gt; 向下取整</li>
<li>public static long round(double num) —&gt; 四舍五入</li>
</ul>
<pre><code class="language-java">System.out.println( Math.abs( -2.3 ) ); //2.3  
System.out.println( Math.ceil( 3.1 ) ); //4.0
System.out.println( Math.floor( 3.9 ) );  //3.0  
System.out.println( Math.round( 5.4 ) );  //5  (不带小数点)
</code></pre>
<hr>
<h2 id="继承-抽象类">继承 &amp; 抽象类</h2>
<p>面向对象的三大特性：封装性 / <strong>继承性</strong> / 多态性<br>
（继承是多态的前提）<br>
子类定义：  <code>public class 子类名称 extends 父类名称 { // …… }</code></p>
<ul>
<li>父子类的方法调用的成员变量重名：
<ul>
<li>直接通过子类对象访问成员变量：  <code>子类名.变量名</code></li>
<li>间接通过成员方法访问成员变量：<br>
该方法属于谁，就优先用谁，没有则向上找</li>
</ul>
</li>
<li>子类中变量重名
<ul>
<li>局部变量：      直接写成员变量名</li>
<li>本类的成员变量： this.成员变量名</li>
<li>父类的成员变量： super.成员变量名</li>
</ul>
</li>
<li>父子类的方法重名：<br>
创建对象的是谁，就优先用谁，没有则向上找</li>
</ul>
<pre><code class="language-java">(1)
public class Fu{
  int num = 10;
  public void methodFu(){
    System.out.println(num);
  }
}
(2)
public class Zi extends Fu{
  int num = 25;
  public void methodZi(){
    System.out.println(num);
  }
  public void methodZi(){
    int num = 30;
    System.out.println( num );        //30  局部变量
    System.out.println( this.num );   //25  本类中的成员变量  
    System.out.println( super.num );  //10  父类的成员变量
  }
}
(3)//主函数  
Fu fu = new Fu(); //创建父类对象
Zi zi = new Zi(); //创建子类对象
System.out.println(zi.num); //25  优先子类
zi.methodZi();  //25  方法为子类的，优先用子类变量
zi.methodFu();  //10  方法在父类中定义
</code></pre>
<ul>
<li>重载Overload：          方法名称一样，<u>参数列表不一样</u></li>
</ul>
<h4 id="重写覆写覆盖override"><strong>重写/覆写/覆盖Override</strong>：</h4>
<ol>
<li>方法名称一样，<u>参数列表也一样  </u></li>
<li>子类方法的返回值必须 &lt;= 父类方法的返回值<br>
（ Object类是所有类的公共最高父类(祖宗类) )</li>
<li>子类方法权限 &gt;= 父类方法权限<br>
public &gt; protected &gt; default(不写) &gt; private</li>
</ol>
<p><strong>@Override</strong>：写在方法的上一行，检测覆盖重写是否正确</p>
<blockquote>
<p>对于已经使用的类，尽量不修改，继承后重复利用相同的功能，通过覆盖重写进行改动</p>
</blockquote>
<pre><code class="language-java">(1) public class Fu{
  public void show(){
    System.out.println(&quot;老功能&quot;);
  }
}
(2) public class Zi extends Fu{
  @Override
  public void show(){
    super.show();     // 可以把父类的show方法拿来重复利用
    System.out.println(&quot;新功能&quot;);
  }
}
</code></pre>
<h4 id="构造方法-3">构造方法：</h4>
<ol>
<li>子类必须调用父类构造方法，不写则默认调用父类无参构造方法<code>super()</code><br>
<strong>先调用父类构造，再执行子类构造</strong></li>
<li>只有子类构造方法才能调用父类构造方法，且只能调用一个</li>
<li>super的父类构造调用，必须是子类构造方法的第一个语句</li>
<li>若父类只有构造有参，子类不写会报错：默认的是父类无参<code>super()</code></li>
</ol>
<h4 id="super关键字">super关键字</h4>
<ol>
<li>在子类的成员方法中，访问父类的成员变量</li>
<li>在子类的成员方法中，访问父类的成员方法</li>
<li>在子类的构造方法中，访问父类的构造方法</li>
</ol>
<h4 id="this关键字">this关键字</h4>
<ol>
<li>在本类的成员方法中，访问本类的成员变量</li>
<li>在本类的成员方法中，调用本类的另一个成员方法</li>
<li>在本类的构造方法中，调用本类的另一个构造方法  （构造方法的重载调用）<br>
this(……)的调用也必须是构造方法的第一个语句，且唯一<br>
super和this两种构造调用，不能同时</li>
</ol>
<h3 id="继承">继承</h3>
<p>Java语言为<strong>单继承</strong>：一个类的直接父亲只能有一个<br>
Java语言可以<strong>多级继承</strong>： 最高级父类为java.lang.Object</p>
<ul>
<li>一个子类的直接父类是唯一的，但一个父类可以有多个子类</li>
</ul>
<h4 id="抽象">抽象</h4>
<ul>
<li>抽象方法：父类中的方法不确定用什么方法体 { } 实现<br>
加上abstract关键字，去掉大括号，直接分号结束</li>
<li>抽象方法必须定义在抽象类中，抽象类中不一定有抽象方法</li>
<li>抽象类：
<ol>
<li>不能创建new抽象类对象，要用一个子类来继承抽象父类</li>
<li>子类必须覆盖重写抽象父类中的<strong>所有</strong>的抽象方法 （除非子类也抽象）<br>
去掉抽象方法的abstract关键字，然后补上方法体</li>
</ol>
</li>
</ul>
<blockquote>
<p>光标放在子类class的extends上 —&gt; Alt + Enter —&gt; Implement methods + Enter —&gt; Enter —&gt; 生成所有需要覆盖重写的方法</p>
</blockquote>
<hr>
<h2 id="接口">接口</h2>
<ul>
<li>接口为多个类的公共规范，为一种引用数据类型<br>
<code>public interface 接口名称 { //接口内容 }</code><br>
换成关键字interface后，依然是 .java —&gt; .class</li>
<li>Java 8 的接口可包含：<br>
1.常量 2.抽象方法 3.默认方法 4.静态方法 5.私有方法(Java 9)</li>
</ul>
<blockquote>
<p>在package中New —&gt; Java Class —&gt; Kind —&gt; 选择Interface (向下箭头)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows快捷键]]></title>
        <id>https://chtholist.gitee.io/post/windows-kuai-jie-jian/</id>
        <link href="https://chtholist.gitee.io/post/windows-kuai-jie-jian/">
        </link>
        <updated>2020-03-22T03:18:04.000Z</updated>
        <content type="html"><![CDATA[<p>Win键 +E  		打开资源管理器<br>
Win键 + Shift + S 		截屏<br>
Win键 + L			锁屏<br>
windows键+R，输入psr.exe回车	屏幕录制<br>
Win键 + D		返回桌面<br>
Win键 +Ctrl+D		添加虚拟桌面<br>
Win键 +Ctrl+F4		删除虚拟桌面<br>
Win键 + ←/→	                左右分屏<br>
Windows+R，输入osk	虚拟键盘</p>
<p>C:\Users\你的名字		windows的管理员账号文件夹</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows快捷键]]></title>
        <id>https://chtholist.gitee.io/post/windows/</id>
        <link href="https://chtholist.gitee.io/post/windows/">
        </link>
        <updated>2020-03-22T03:18:04.000Z</updated>
        <content type="html"><![CDATA[<p>Win键 +E  		打开资源管理器<br>
Win键 + Shift + S 		截屏<br>
Win键 + L			锁屏<br>
windows键+R，输入psr.exe回车	屏幕录制<br>
Win键 + D		返回桌面<br>
Win键 +Ctrl+D		添加虚拟桌面<br>
Win键 +Ctrl+F4		删除虚拟桌面<br>
Win键 + ←/→	                左右分屏<br>
Windows+R，输入osk	虚拟键盘</p>
<p>C:\Users\你的名字		windows的管理员账号文件夹</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown学习笔记]]></title>
        <id>https://chtholist.gitee.io/post/markdown/</id>
        <link href="https://chtholist.gitee.io/post/markdown/">
        </link>
        <updated>2020-03-22T03:17:09.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="title-markdown-笔记date-2020-02-26-174147tags-学习published-truehideinlist-falsefeature-post-imagesmarkdownlearningjpgistop-false">title: 'Markdown 笔记'<br>
date: 2020-02-26 17:41:47<br>
tags: [学习]<br>
published: true<br>
hideInList: false<br>
feature: /post-images/MARKDOWNlearning.jpg<br>
isTop: false</h2>
<h1 id="一级标题">一级标题</h1>
<h2 id="二级标题">二级标题</h2>
<h1 id="一级标题-2">一级标题</h1>
<h2 id="二级标题-2">二级标题</h2>
<h3 id="三级标题">三级标题</h3>
<h4 id="四级标题">四级标题</h4>
<h5 id="五级标题">五级标题</h5>
<h6 id="六级标题">六级标题</h6>
<p>（没有七级标题，#后面要有一个空格）</p>
<h1 id="文本形式">文本形式</h1>
<p><em>斜体文本</em><br>
<em>斜体文本</em><br>
<strong>粗体文本</strong><br>
<strong>粗体文本</strong><br>
<em><strong>粗斜体文本</strong></em><br>
<em><strong>粗斜体文本</strong></em><br>
（空两格再回车 = 换行）</p>
<hr>
<hr>
<hr>
<hr>
<p>（三个以上星号/减号/底线建立分割线，行内不能有其他东西）</p>
<p><s>删除线</s></p>
<p><u>下划线</u> (HTML文本)</p>
<p>创建[^脚注]<br>
[^脚注]：这里写着脚注<br>
（存疑）</p>
<h1 id="列表">列表</h1>
<p>无序列表</p>
<ul>
<li>第一项 （星号*</li>
<li>第二项</li>
</ul>
<ul>
<li>第三项 （加号+</li>
<li>第四项</li>
</ul>
<ul>
<li>第五项 （减号-</li>
<li>第六项<br>
（注意空格）</li>
</ul>
<p>有序列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项<br>
（注意空格</li>
</ol>
<p>列表嵌套</p>
<ol>
<li>第一项
<ul>
<li>第一项中的第一个嵌套</li>
</ul>
</li>
<li>第二项
<ul>
<li>第二项中的第一个嵌套<br>
（在嵌套项前加<strong>四个空格</strong>）</li>
</ul>
</li>
</ol>
<blockquote>
<p>区块引用<br>
注意空格</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第三项</li>
</ul>
<ul>
<li>第四项</li>
</ul>
<ul>
<li>第五项</li>
</ul>
</blockquote>
<ul>
<li>列表中使用区块
<blockquote>
<p>添加四个空格的缩进</p>
</blockquote>
</li>
</ul>
<h1 id="代码块">代码块</h1>
<ol>
<li>
<p>行内代码片段——键盘左上方反引号<br>
<code>int main()</code></p>
</li>
<li>
<p>自定义语法</p>
</li>
</ol>
<pre><code class="language-c++">int main()
{
    printf(&quot;sojf&quot;);
}
</code></pre>
<h1 id="链接">链接</h1>
<blockquote>
<ul>
<li>
<p>[链接名称]（链接地址）<br>
这是菜鸟教程的链接<a href="https://www.runoob.com/markdown/md-link.html">Markdown链接</a></p>
</li>
<li>
<p>直接使用链接网址   &lt; xxx &gt;<br>
<a href="https://www.runoob.com/markdown/md-link.html">https://www.runoob.com/markdown/md-link.html</a></p>
</li>
<li>
<p>高级链接，用变量代替，文档末尾附带变量地址<br>
菜鸟教程<a href="https://www.runoob.com/markdown/md-link.html">RunooB</a></p>
</li>
</ul>
</blockquote>
<h1 id="图片">图片</h1>
<p><img src="%E5%9B%BE%E7%89%87%E7%BD%91%E5%9D%80" alt="属性文本/图片替代文字" title="图片标题" loading="lazy"><br>
<img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB" loading="lazy"><br>
（无法指定图片的高度和宽度）</p>
<h1 id="表格">表格</h1>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:center">居中对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格1</td>
<td style="text-align:right">单元格2</td>
<td style="text-align:center">单元格3</td>
</tr>
<tr>
<td style="text-align:left">单元格4</td>
<td style="text-align:right">单元格5</td>
<td style="text-align:center">单元格6</td>
</tr>
</tbody>
</table>
<h1 id="任务列表">任务列表</h1>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6914544"><label class="task-list-item-label" for="task-item-6914544"> 选项一</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1925184"> 选项二<br>
(方框中间要有x或<strong>空格</strong><label class="task-list-item-label" for="task-item-1925184"> 选项二  
(方框中间要有x或**空格**)</label></li>
</ul>
<h1 id="空格">空格</h1>
<p>在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加<br>
<u><strong>注意分号</strong></u></p>
<ul>
<li>不换行空格     &amp;nbsp;</li>
<li>半角空格         &amp;ensp;</li>
<li>全角空格       &amp;emsp;</li>
</ul>
<h1 id="其他">其他</h1>
<ul>
<li>
<p>支持HTML元素<br>
添加<kbd>方框</kbd></p>
</li>
<li>
<p>转义</p>
<ul>
<li>
<ul>
<li>三级序号<br>
<strong>加粗文本</strong><br>
**正常显示星号**</li>
</ul>
</li>
</ul>
</li>
<li>
<p>公式<br>
（使用$$包裹TeX或LaTeX格式数学公式）</p>
</li>
<li>
<p>x<sup>上标</sup></p>
</li>
<li>
<p>x<sub>下标</sub></p>
</li>
</ul>
<h1 id="快捷键">快捷键</h1>
<ul>
<li>右键Markdown Preview Enhanced 查看pdf预览</li>
</ul>
<p>https://chtholist.github.io/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++学习笔记 —— 运算&表达式]]></title>
        <id>https://chtholist.gitee.io/post/Cstudy4/</id>
        <link href="https://chtholist.gitee.io/post/Cstudy4/">
        </link>
        <updated>2020-03-22T03:15:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数学公式">数学公式</h2>
<p>#include<cmath></p>
<h4 id="开平方-sqrta">开平方 sqrt（a）</h4>
<h4 id="求绝对值-fbsa">求绝对值 fbs（a）</h4>
<h4 id="朝上取整-ceil">朝上取整 ceil（）</h4>
<p>ceil(-3.14) = -3;<br>
ceil(4.56) = 5;</p>
<h4 id="朝下取整-floor">朝下取整 floor（）</h4>
<p>floor(-3.14) = -4;<br>
floor(4.56) = 4;</p>
<h4 id="朝0取整-fix">朝0取整 fix（）</h4>
<p>fix(-3.14) = -3;<br>
fix(4.56) = 4;</p>
<h4 id="四舍五入-round">四舍五入 round（）</h4>
<p>round(-3.14) = -3;<br>
round(4.56) = 5;<br>
round(11.5) = 12;<br>
round(-11.5) = -11;</p>
<h2 id="条件运算符-三元运算符">条件运算符 / 三元运算符</h2>
<ul>
<li>variable x = (expression) ? value if true : value if false<br>
需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量</li>
<li>利用<strong>条件运算符的嵌套</strong>来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。(Java)</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
      System.out.println(&quot;请输入你的分数：&quot;);   
      Scanner scanner=new Scanner(System.in);
      int input=scanner.nextInt();//获取输入
      String belong=  input &gt;= 90 ? &quot;A&quot; : (input&gt;=60?&quot;B&quot;:&quot;c&quot;);     //！！！ (a&gt;b)?a:b  等级判断
      System.out.println(input+&quot;分属于：&quot;+belong);
      scanner.close();    
}
</code></pre>
<h2 id="逗号表达式">逗号表达式</h2>
<p>表达式1，表达式2，表达式3……表达式n<br>
它的值为表达式n的值。<br>
先求解表达式1，再求解表达式2……整个逗号表达式的值是表达式n的值。<br>
逗号运算符是所有运算符中级别最低的。</p>
<pre><code>x=i=4,j=16,k=32;            x=4
y=(i=4,j=16),k=32;          y=16
z=(i=4,j=16,k=32);          z=32
a=(a=3*5,a*4)               a=60
</code></pre>
<h2 id="运算符">运算符</h2>
<ol>
<li>逗号运算符 (，)</li>
<li>指针运算符 (*)</li>
<li>引用运算符和地址运算符 (＆)</li>
<li>求字节数运算符（sizeof）</li>
<li>强制类型转换运算符（ (类型) 或类型( )）</li>
<li>成员运算符 （.）</li>
<li>指向成员的运算符 （-&gt;）</li>
<li>下标运算符 （［ ］）</li>
<li>其他 （  如函数调用运算符（）  ）</li>
</ol>
<h2 id="混合运算">混合运算</h2>
<ul>
<li>进行运算时，不同类型的数据要先转换成同一类型，然后进行运算</li>
<li>横向箭头表示必定的转换</li>
<li>纵向的箭头表示运算对象为不同类型时转换的方向<br>
<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1583169776198&amp;di=ceac46f8aa24f1b64185a1b5e0dc47db&amp;imgtype=0&amp;src=http%3A%2F%2Fp.ananas.chaoxing.com%2Fstar3%2Forigin%2F5476f0aaa310e0448134b8f2.png">类型转换</a></li>
</ul>
<h2 id="if语句">if语句</h2>
<ul>
<li><strong>在嵌套使用if语句时，C语言规定else总是和之前与其最近的且不带else的if配对</strong></li>
</ul>
<pre><code class="language-c++">int  a = 2, b = -1, c = 2;
    if(a &lt; b)
        if(b &lt; 0)  
            c = 0;
        else  c++;
    printf(&quot;%d\n&quot;,c);	//2
//——————————————————————————
int y = 0;		
    if(x &gt;= 0);	
        if(x &gt; 0) 
            y = 1;	
        else y = -1;
//——————————————————————————
if (x &lt; 2)
   if (x &lt; 1)
        y = x + 1; 
   else;
else
   y = x + 2;
</code></pre>
<h2 id="switch">switch</h2>
<ul>
<li>允许测试一个变量等于多个值时的情况。</li>
<li>default在上面所有case都不为真时执行一个任务。</li>
<li>default中的 break 语句不是必需的</li>
<li>case后各常量表达式的值不能相同</li>
<li>多个case可以共用一组执行语句</li>
</ul>
<pre><code class="language-c++">switch(op){
       case a: printf(&quot;%d&quot;, 1); 
       default: printf(&quot;x&quot;); 
       case b: printf(&quot;%d&quot;, 2); 
}
输入a  //1x2
输入b  //2

int  a;
scanf(&quot;%d&quot;, &amp;a);
    if(a &gt; 50)  printf(&quot;%d&quot;, a);      //输入52，输出525252
    if(a &gt; 40)  printf(&quot;%d&quot;, a);      //输入43，输出4343
    if(a &gt; 30)  printf(&quot;%d&quot;, a);
</code></pre>
<h2 id="判断字符类型-include-ctypeh">判断字符类型   #include &lt;ctype.h&gt;</h2>
<ol>
<li>字母和数字      <code>int isalnum(int c);</code></li>
<li>字母            <code>int isalpha(int c);</code></li>
<li>控制字符        <code>int iscntrl(int c);</code></li>
<li>十进制数字字符   <code>int isdigit(int c);</code></li>
<li>小写字母        <code>int islower(int c);</code></li>
<li>大写字母。      <code>int isupper(int c)</code></li>
<li>标点符号字符    <code>int ispunct(int c)</code></li>
</ol>
<h2 id="循环">循环</h2>
<ol>
<li><strong>break</strong> ——&gt; 结束循环，跳出循环体,进行后面的程序；</li>
<li><strong>continue</strong> ——&gt; 结束本次循环(不执行本循环内的其他语句)，直接进行下次循环；</li>
<li><strong>return</strong> ——&gt; 跳出循环体所在的方法，相当于结束该方法。</li>
<li><strong>goto</strong> ——&gt; 直接goto到某个地方继续执行</li>
</ol>
<h3 id="有多层for循环">有多层for循环</h3>
<ol>
<li>break会跳出当前这一层,去执行外一层循环(而不是退出所有层循环);</li>
<li>continue则跳过当前循环中的代码，强迫开始下一次循环。<br>
(注意一层循环和一次循环的区别:一层循环包含若干(i)次循环)</li>
<li>continue 语句执行后自增语句仍然会执行。</li>
</ol>
<h3 id="键盘操作">键盘操作</h3>
<ol>
<li><strong>ctrl-c</strong> ——&gt; 发送 SIGINT 信号给前台进程组中的所有进程。常用于终止正在运行的程序。</li>
<li><strong>ctrl-z</strong> ——&gt; 发送 SIGTSTP 信号给前台进程组中的所有进程，常用于挂起一个进程。
<ul>
<li>C/C++程序中，cin为读入标准输入格式，直到遇到文件结束符时结束运行</li>
<li>而在Windows中CTRL+Z相当于文件结束符EOF，所以你键入CTRL+Z回车后跳出了While循环，才能执行到程序后面的内容。如果缓冲中还有其它内容，ctrl+z不表示输入结束，仅代表当前行输入结束，只在单独一个ctrl+z的时候才表示输入结束。即输入数据后按回车，之后在下一行输入Ctrl+Z继续执行程序。</li>
<li>只有当Ctrl+Z单独位于一行的行首时，才表示输入的终止！ （即无论何时，都推荐先回车，再Ctrl+Z，再回车结束输入）</li>
<li>当Ctrl+Z位于行中、行末时，输入都不会结束。(Ctrl+Z表示一个字符，其ASCII码为26.）</li>
</ul>
</li>
<li><strong>ctrl-d</strong> ——&gt; 不是发送信号，而是表示一个特殊的二进制值，表示 EOF。</li>
</ol>
<h2 id="eof">EOF</h2>
<p>EOF为定义在头文件&lt;stdio.h&gt;的常量，为-1<br>
函数读入文件数据时，函数会返回一个状态，标识符为EOF<br>
EOF为文件操作函数，在文件结尾操作时返回<br>
EOF在UNIX中为ctrl+d，在win中为ctrl+z</p>
<h2 id="排序函数sort">排序函数Sort（ ）</h2>
<ul>
<li>时间复杂度为n*log2(n)，执行效率较高</li>
<li>头文件为#include<algorithm><br>
三个参数：</li>
</ul>
<ol>
<li>第一个是要排序的数组的起始地址。</li>
<li>第二个是结束的地址（最后一位要排序的地址）</li>
<li>第三个参数是排序的方法，不写第三个参数，此时默认的排序方法是从小到大排序。Sort(start,end,排序方法)</li>
</ol>
<ul>
<li>加入一个比较函数 complare()</li>
</ul>
<pre><code class="language-c">bool complare(int a,int b)
{ return a&gt;b;} 
sort(a,a+10,complare);      //在这里就不需要对complare函数传入参数了
</code></pre>
<ul>
<li>从小到大排序less&lt;数据类型&gt;( )     <code>sort(a,a+10,less&lt;int&gt;( ));</code></li>
<li>从大到小排序greater&lt;数据类型&gt;( )  <code>sort(a,a+10,greater&lt;int&gt;( ));</code></li>
<li>对字符的排序<br>
sort(a,a+10,greater<char>( ));<br>
sort(str.begin(),str.end( ));</li>
</ul>
<hr>
<ul>
<li>程序中的循环不会无限循环<br>
任何一个数据类型是有位数限制，好似int在C语言里就固定为32位带符号的整数类型，范围是-2147483648～2147483647，当不断增加一时，超过了就会溢出，返回到负的尽头</li>
</ul>
]]></content>
    </entry>
</feed>